[toc]







## [数据结构探险-队列篇](https://www.imooc.com/learn/519)

> 简介：本课程将和大家一起领略数据结构的精巧设计并详细的演示队列结构的实现，课程以原理为基础，同时以C++编码做为效果实现。使大家可以由表及里，由浅入深的进入数据结构的美妙世界。

### 第1章 课程简介

####  1-1 课程简介 (02:13)

![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200314093957.png)

- 数据结构是指相互之间存在一种或多种特定关系的数据元素的集合

![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200314094046.png)



### 第2章 队列原理

> 本章讲述了队列结构的原理。

#### 2-1 队列 (07:37)

- 先入先出--FIFO

- 普通队列存在的缺点：
  - 若是一个元素出队列后，其他元素统一前移，补充空位，则时间效率降低。
  - 若是一个元素出队列后，其他元素位置保持不变，空位保留，则空间利用率低。
- 环形队列：充分利用内存空间

![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200314100234.png)

![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200314100157.png)





### 第3章 队列结构的面向对象设计

> 本章讲述了环形队列的设计技巧及必要的队列函数

首先要明确数据结构和数据存储结构的概念。

- 数据结构是指数据对象之间的逻辑关系，例如二叉树，队列，栈等，
- 数据存储结构是描述数据在计算机上的存储方式，
  - 它分为顺序存储和非顺序存储，
  - 数组就是典型的顺序存储。
  - **链表**就是典型的非顺序存储，它需要知道前一个数据和后一个数据。
- **队列**是一种数据结构，它可以采用顺序存储也可以采用非顺序存储。



####  3-1 面向对象的队列设计 (10:43)

```c
class MyQueue
{
	// 注释：讲解一些 C 语言用法
public:
	MyQueue(int queueCapacity);		// InitQueue(&Q) 创建队列
	virtual ~MyQueue();				// DestoryQueue(&Q) 销毁队列
	void ClearQueue();				// ClearQueue(&Q) 清空队列
	bool QueueEmpty() const;		// QueueEmpty(Q）判空队列
    bool QueueFull() const;			// QueueFull(Q) 判满队列
	int QueueLength() const;		// QueueLength(Q) 队列长度
	bool EnQueue(int element);		// EnQueue(&Q, element) 新元素入队
	bool DeQueue(int &element);		// DeQueue(&Q, &element）首元素出队
	void QueueTraverse();			// QueueTraverse(Q,visit()) 遍历队列，visit()函数：访问队列元素的方法
private:
	int *m_pQueue;					// 队列数组指针
	int m_iQueuelen;				// 队列元素个数
	int m_iQueueCapacity;			// 队列数组容量
};
```



### 第4章 环形队列代码实现

> 本章讲述了环形队列的具体实现方法及代码检测方法。

####  4-1 环形队列实现上 (12:23)

队列有两个重要的元素：队头和队尾；

- 插入元素：
  - 当我们插入一个元素时，先判断这个队列是不是满的。
  - 插入元素，队尾会变化
- 删除元素：
  - 当我们删除一个元素时，先判断这个队列是不是空的。
  - 删除元素，队头会变化



#### 4-2 环形队列实现下 (16:52)

- 出队需要element返回值 所以需引用： `&elem`
- 环形队列入队： `head++; head = head % capacity;`
- 环形队列出队： `tail++; tail = tail % capacity;`

##### MyQueue--队列类

```c
//MyQueue.h
#pragma once
#include <iostream>
using namespace std;
class MyQueue {
public:
	MyQueue(int queueCapacity);
	virtual ~MyQueue();
	void ClearQueue();
	bool QueueEmpty() const;
	bool QueueFull() const;
	int QueueLength() const;
	bool Enqueue(int elem);
	bool Dequeue(int &elem);
	void QueueTraverse();
private:
	int* m_pQueue;
	int m_iQueueLength;
	int m_iQueueCapacity;
	int m_iHead;	//队头--数组下标
	int m_iTail;	//队尾--数组下标
};
```

```cpp 
//MyQueue.cpp
#include "MyQueue.h"
MyQueue::MyQueue(int queueCapacity)
{
	m_iQueueCapacity = queueCapacity;
	ClearQueue();
	m_pQueue = new int[m_iQueueCapacity];
}
MyQueue::~MyQueue()
{
	delete[] m_pQueue;
	m_pQueue = nullptr;
}
void MyQueue::ClearQueue()
{
	m_iHead = 0;
	m_iTail = 0;
	m_iQueueLength = 0;
}
bool MyQueue::QueueEmpty() const
{
	return m_iQueueLength == 0 ? true : false;
}
bool MyQueue::QueueFull() const
{
	return m_iQueueLength == m_iQueueCapacity ? true : false;
}
int MyQueue::QueueLength() const
{
	return m_iQueueLength;
}
bool MyQueue::Enqueue(int elem)
{
	if (QueueFull()) return false;
	else {
		m_pQueue[m_iTail] = elem;
		m_iTail++;
		m_iTail %= m_iQueueCapacity;	//環形隊列
		m_iQueueLength++;				//隊列長度+1
		return true;
	}
}
bool MyQueue::Dequeue(int& elem)
{
	if (QueueEmpty()) return false;
	else {
		elem = m_pQueue[m_iHead];
		m_iHead++;
		m_iHead %= m_iQueueCapacity;	//環形隊列
		m_iQueueLength--;
		return true;
	}
}

void MyQueue::QueueTraverse()
{
	for (int i = 0; i != m_iQueueLength; i++)
	{
		cout << m_pQueue[(m_iHead + i) % m_iQueueCapacity] << " ";
	}
	cout << endl;
}
//for (int i = m_iHead; i < m_iHead + m_iQueueLen; ++i)
//{
//	cout << m_pQueue[i % m_iQueueCapacity] << endl;
//}
```



#### 4-3 环形队列检测 (10:18)

```c
#include <iostream>
#include "MyQueue.h"
using namespace std;
int main()
{
	MyQueue* p = new MyQueue(4);
	p->Enqueue(2);
	p->Enqueue(4);
	p->Enqueue(7);
	p->Enqueue(1);
	p->Enqueue(8);
	p->QueueTraverse();

	int e = 0;
	p->Dequeue(e);
	cout << e << endl;
	p->Dequeue(e);
	cout << e << endl;
	p->QueueTraverse();

	p->ClearQueue();
	p->QueueTraverse();

	p->Enqueue(13);
	p->Enqueue(16);
	p->QueueTraverse();

	delete p;
	p = nullptr;
}
```



### 第5章 升华与应用

> 本章在代码完成的基础上提出更多灵活的变化，同时讲述在排号中的应用。

#### 5-1 队列的实际应用 (14:04)

##### MyQueue--队列类模板

```c
//MyQueue.h
#pragma once
#include <iostream>
using namespace std;
template<typename T>
class MyQueue {
public:
	MyQueue(int queueCapacity);
	virtual ~MyQueue();
	void ClearQueue();
	bool QueueEmpty() const;
	bool QueueFull() const;
	int QueueLength() const;
	bool Enqueue(T elem);
	bool Dequeue(T& elem);
	void QueueTraverse();

private:
	T* m_pQueue;
	int m_iQueueLength;
	int m_iQueueCapacity;
	int m_iHead;	//队头--数组下标
	int m_iTail;	//队尾--数组下标
};
template<typename T>
MyQueue<T>::MyQueue(int queueCapacity)
{
	m_iQueueCapacity = queueCapacity;
	ClearQueue();
	m_pQueue = new T[m_iQueueCapacity];
}
template<typename T>
MyQueue<T>::~MyQueue()
{
	delete[] m_pQueue;
	m_pQueue = nullptr;
}
template<typename T>
void MyQueue<T>::ClearQueue()
{
	m_iHead = 0;
	m_iTail = 0;
	m_iQueueLength = 0;
}
template<typename T>
bool MyQueue<T>::QueueEmpty() const
{
	return m_iQueueLength == 0 ? true : false;
}
template<typename T>
bool MyQueue<T>::QueueFull() const
{
	return m_iQueueLength == m_iQueueCapacity ? true : false;
}
template<typename T>
int MyQueue<T>::QueueLength() const
{
	return m_iQueueLength;
}
template<typename T>
bool MyQueue<T>::Enqueue(T elem)
{
	if (QueueFull()) return false;
	else {
		m_pQueue[m_iTail] = elem;
		m_iTail++;
		m_iTail %= m_iQueueCapacity;	//環形隊列
		m_iQueueLength++;				//隊列長度+1
		return true;
	}
}
template<typename T>
bool MyQueue<T>::Dequeue(T& elem)
{
	if (QueueEmpty()) return false;
	else {
		elem = m_pQueue[m_iHead];
		m_iHead++;
		m_iHead %= m_iQueueCapacity;	//環形隊列
		m_iQueueLength--;
		return true;
	}
}
template<typename T>
void MyQueue<T>::QueueTraverse()
{
	for (int i = 0; i != m_iQueueLength; i++)
	{
		cout << m_pQueue[(m_iHead + i) % m_iQueueCapacity];
		cout << "前面还有" << i << "人" << endl;
		cout << endl;
	}
}
//for (int i = m_iHead; i < m_iHead + m_iQueueLen; ++i)
//{
//	cout << m_pQueue[i % m_iQueueCapacity] << endl;
//}
```

##### Customer--顾客类

```c
// Customer.h
#pragma once
#include <string>
#include <iostream>
using namespace std;
class Customer {
	friend ostream& operator<<(ostream& out, const Customer& cust);	//<<运算符重载
public:
	Customer(string name = "", int age = 0);
private:
	string m_strName;
	int m_iAge;
};

// Customer.cpp
#include "Customer.h"
Customer::Customer(string name, int age)
	:m_strName(name), m_iAge(age)	// 	:m_strName{ name }, m_iAge{ age }
{}
ostream& operator<<(ostream& out, const Customer& cust) {
	out << "姓名: " << cust.m_strName << endl;
	out << "年龄: " << cust.m_iAge << endl;
	return out;
}
```

##### 使用

```c
//demo.cpp
#include <iostream>
#include "Customer.h"
#include "MyQueue.h"
using namespace std;
int main() {
	MyQueue<Customer>* p = new MyQueue<Customer>(6);
	Customer c1{ "杨格尔", 22 };	// Customer c1("杨格尔", 22);  
	Customer c2 = { "Younger", 14 };
	Customer* c3 = ncew Customer("Baby", 4); 
    // new Customer{ "Baby", 4 };
    // Customer c[] = { {"dablelv",18},{"tommy",19} };
	p->Enqueue(c1);
	p->Enqueue(c2);
	p->Enqueue(*c3);
	p->QueueTraverse();
	
	Customer c4("", 0);
	p->Dequeue(c4);
	cout << c4 << endl;
	p->QueueTraverse();
}
```







## [数据结构探险-栈篇](https://www.imooc.com/learn/611)

> 简介：本课程将带领大家体会栈这种数据结构的美妙，并详细讲解从单一数据类型栈到栈模板的升华过程，最后安排数制转换及括号匹配的例子，使学员可以通过例子对栈的知识有更深刻的理解和认识，所有知识均通过编码实践的方式讲解到操作层面，力求即学即会。



### 第1章 栈的工作原理

> 本章讲述了栈作为数据结构的特点及工作原理。

####  1-1 栈介绍 (04:16)

栈是一种先进后出的机制

LIFO: last in first out

### 第2章 单一数据类型栈

> 本章讲述了单一数据类型栈的编码技巧。

#### 2-1 实例介绍 (06:44)

```c
public:
	MyStack(int size);		//分配内存初始化栈空间，设定栈容量，栈顶
	~MyStack();				//回收栈空间内存
	bool stackEmpty();		//判断栈是否为空
	bool stackFull();		//判断栈是否为满
	void clearStack();		//清空栈
	int stackLength();		//栈中元素个数
	bool push(char elem);	//将元素压入栈中，栈顶上 
	bool pop(char &elem);	//将元素推出栈，栈顶下降
	void stackTraverse();	//遍历栈中元素并输出
private:
	int m_iTop;				//栈顶，栈中元素个数
	int m_iSize;			//栈容量
	char *m_pBuffer;		//栈空间指针
```



#### 2-2 实例演示一 (09:23)

push函数也可改为返回void，通过异常处理判断是否入栈

pop函数也可改为返回char，也不用返回引用了，通过异常处理判断是否出栈

```c
char MyStack::pop() {
	if (stackEmpty()) {
		throw 1;
	}
	else {
		return m_pBuffer[--m_iTop];
	}
}

```

#### 2-3 实例演示二 (14:08)

##### MyStack--栈类

```c
//MyStack.h
#pragma once
#include <iostream>
using namespace std;
class MyStack {
public:
	MyStack(int size);		//分配内存初始化栈空间，设定栈容量，栈顶
	~MyStack();				//回收栈空间内存
	bool stackEmpty();		//判断栈是否为空
	bool stackFull();		//判断栈是否为满
	void clearStack();		//清空栈
	int stackLength();		//栈中元素个数
	bool push(char elem);	//将元素压入栈中，栈顶上升
	bool pop(char& elem);	//将元素推出栈，栈顶下降
	void stackTraverse(bool isFromButtom);	//遍历栈中元素并输出
private:
	int m_iTop;				//栈顶，栈中元素个数
	int m_iSize;			//栈容量
	char* m_pBuffer;		//栈空间指针
};
```

```c
//MyStack.cpp
#include "MyStack.h"
MyStack::MyStack(int size) {
	m_iSize = size;
	m_pBuffer = new char[m_iSize];
	m_iTop = 0;		//空栈特征：栈顶为0
}
MyStack::~MyStack() {
	delete[] m_pBuffer;	//可以不置nullptr，因为对象已经被销毁了
}
bool MyStack::stackEmpty() {
	return m_iTop == 0;
}
bool MyStack::stackFull() {
	return m_iSize == m_iTop;
}
void MyStack::clearStack() {
	m_iTop = 0;
}
int MyStack::stackLength() {
	return m_iTop;
}
bool MyStack::push(char elem) {
	if (stackFull()) return false;
	else {
		m_pBuffer[m_iTop] = elem;
		m_iTop++;
		return true;
	}
}
bool MyStack::pop(char& elem) {
	if (stackEmpty()) return false;
	else {
		m_iTop--;
		elem = m_pBuffer[m_iTop];
		return true;
	}
}
void MyStack::stackTraverse(bool isFromButtom) {
	if (isFromButtom) {
		for (int i = 0; i < m_iTop; i++) {
			cout << m_pBuffer[i] << " ";
		}
		cout << endl;
	}
	else {
		for (int i = m_iTop - 1; i >= 0; i--) {
			cout << m_pBuffer[i] << " ";
		}
		cout << endl;
	}
}
```



#### 2-4 演示代码运行 (12:09)

```c
#include <iostream>
#include "Customer.h"
#include "MyQueue.h"
#include "MyStack.h"
using namespace std;
int main() {
	MyStack* pStack = new MyStack(5);
	pStack->push('h');
	pStack->push('e');
	pStack->push('l');
	pStack->push('l');
	pStack->push('o');
	pStack->stackTraverse(true);

	char elem = 0;
	pStack->pop(elem);
	cout << elem << endl;
	//pStack->clearStack();

	pStack->stackTraverse(false);
	cout << pStack->stackLength() << endl;

	if (pStack->stackEmpty()) { cout << "栈为空" << endl; }
	if (pStack->stackFull()) { cout << "栈为满" << endl; }

	delete pStack;
	pStack = nullptr;
}
```



### 第3章 栈模板

> 本章讲解了如何将单一数据类型栈改造为支持多类型的栈模板。

#### 3-1 案例改造 (13:29)

##### MyStack--栈类模板

```c
#pragma once
#include <iostream>
using namespace std;
template <typename T>
class MyStack {
public:
	MyStack(int size);		//分配内存初始化栈空间，设定栈容量，栈顶
	~MyStack();				//回收栈空间内存
	bool stackEmpty();		//判断栈是否为空
	bool stackFull();		//判断栈是否为满
	void clearStack();		//清空栈
	int stackLength();		//栈中元素个数
	bool push(T elem);	//将元素压入栈中，栈顶上升
	bool pop(T& elem);	//将元素推出栈，栈顶下降
	void stackTraverse(bool isFromButtom);	//遍历栈中元素并输出
private:
	int m_iTop;				//栈顶，栈中元素个数
	int m_iSize;			//栈容量
	T* m_pBuffer;		//栈空间指针
};
#include "MyStack.h"

template <typename T>
MyStack<T>::MyStack(int size) {
	m_iSize = size;
	m_pBuffer = new T[m_iSize];
	m_iTop = 0;		//空栈特征：栈顶为0
}

template <typename T>
MyStack<T>::~MyStack() {
	delete[] m_pBuffer;	//可以不置nullptr，因为对象已经被销毁了
}

template <typename T>
bool MyStack<T>::stackEmpty() {
	return m_iTop == 0;
}

template <typename T>
bool MyStack<T>::stackFull() {
	return m_iSize == m_iTop;
}

template <typename T>
void MyStack<T>::clearStack() {
	m_iTop = 0;
}

template <typename T>
int MyStack<T>::stackLength() {
	return m_iTop;
}

template <typename T>
bool MyStack<T>::push(T elem) {
	if (stackFull()) return false;
	else {
		m_pBuffer[m_iTop] = elem;
		m_iTop++;
		return true;
	}
}

template <typename T>
bool MyStack<T>::pop(T& elem) {
	if (stackEmpty()) return false;
	else {
		m_iTop--;
		elem = m_pBuffer[m_iTop];
		return true;
	}
}

template <typename T>
void MyStack<T>::stackTraverse(bool isFromButtom) {
	if (isFromButtom) {
		for (int i = 0; i < m_iTop; i++) {
			cout << m_pBuffer[i] << " ";
		}
		cout << endl;
	}
	else {
		for (int i = m_iTop - 1; i >= 0; i--) {
			cout << m_pBuffer[i] << " ";
		}
		cout << endl;
	}
}
```

##### Coordinate--坐标类

```c
//Coordinate.h
#pragma once
#include<iostream>
using namespace std;
class Coordinate {
	friend ostream& operator<<(ostream& out, const Coordinate& coor);
public:
	Coordinate(int x = 0, int y = 0);
public:
	int m_iX;
	int m_iY;
};

//Coordinate.cpp
#include "Coordinate.h"
Coordinate::Coordinate(int x, int y) {
	m_iX = x, m_iY = y;
}
ostream& operator<<(ostream& out, const Coordinate& coor) {
	out << "(" << coor.m_iX << "," << coor.m_iY << ")";
	return out;
}
```

##### 使用

```c
#include <iostream>
#include "Coordinate.h"
#include "MyStack.h"
using namespace std;
int main() {
	MyStack<Coordinate>* pStack = new MyStack<Coordinate>(5);
	pStack->push(Coordinate(0,1));
	pStack->push(Coordinate(2,3));
	pStack->push(Coordinate(4,5));
	pStack->stackTraverse(true);

	Coordinate elem = { 7,8 };
	pStack->pop(elem);
	cout << elem << endl;
	//pStack->clearStack();

	pStack->stackTraverse(false);
	cout << pStack->stackLength() << endl;

	delete pStack;
	pStack = nullptr;
}
```

3-2 案例完善 (12:05)



### 第4章 栈用例

> 本章讲解了数制转换及括号匹配中栈的重要作用。

#### 4-1 栈应用进制转换一 (14:00)

(1348)~10~=(10101000100)~2~=(2504)~8~=(544)~16~

```c
#include <iostream>
#include "MyStack.h"

#define Binary 2;
#define Octonary 8;
#define Hexadecimal 16;
using namespace std;
int main() {
	MyStack<int>* ps = new MyStack<int>(30);
	int N = 1348;
	int mod = 0;
	while (N != 0) {
		mod = N % Hexadecimal;
		ps->push(mod);
		N /= Hexadecimal;
	}
	ps->stackTraverse(false);
	delete ps;
	ps = nullptr;
}
```



封装为函数

```c
#include <iostream>
#include "MyStack.h"
using namespace std;
void scaleTo(int N, int scale) {
	int mod = 0;
	MyStack<int>* ps = new MyStack<int>(30);
	while (N != 0) {
		mod = N % scale;
		N /= scale;
		ps->push(mod);
	}
	int elem = 0;
	while (ps->stackLength() != 0) {
		ps->pop(elem);
		cout << elem;
	}
}
int main() {
	scaleTo(1348, 2);
}
```



#### 4-2 栈应用进制转换二 (06:29)

前面的算法存在的缺陷：无法转换部分16进制

法一：给栈类模板添加 `[ ]`索引运算符重载

```c
//MyStack.h
T& operator[](int index) const;

template<typename T>
T& MyStack<T>::operator[](int index) const {
	return m_pBuffer[index];
}
```

```c
	char num[] = "0123456789ABCDEF";
	for (int i = ps->stackLength() - 1; i >= 0; i--) {
		cout << num[ps->operator[](i)];	 //or cout << num[(*ps)[i]];
	}
```



法二：pop

```c
	char num[] = "0123456789ABCDEF";
	int elem = 0;
	while (ps->stackEmpty() == 0) {
		ps->pop(elem);
		cout << num[elem];
	}

//or
	char num[] = "0123456789ABCDEF";
	int elem = 0;
	for (int i = ps->stackLength() - 1; i >= 0; i--) {
		ps->pop(elem);
		cout << num[elem];
	}
```



#### 4-3 栈应用括号匹配一 (08:30)

计算机会把当前扫描到的非匹配括号入栈，若当前扫描到的是匹配括号则出栈

法一：两个栈

```c
#include <iostream>
#include "MyStack.h"
using namespace std;
void bracketMatch(const char* str) {
	MyStack<char>* pScan = new MyStack<char>(30);	// 扫描到的未匹配括号
	MyStack<char>* pMatch = new MyStack<char>(30);	// 待匹配括号
	char currentNeed = 0;
	for (int i = 0; i < strlen(str); i++) {
		//若遇到\\转义字符，则跳过当前与下一次循环
		//if (str[i] == '\\') { i++; continue; }
		//若遇到非括号字符，则跳过当前循环
		if (str[i] != '(' && str[i] != ')' && str[i] != '[' && str[i] != ']') continue;
		if (str[i] != currentNeed) {	// 当前扫描到的括号 不是 待匹配括号(闭括号)
			pScan->push(str[i]);
			switch (str[i]) {
			case '[':	// 开括号
				if (currentNeed != 0) pMatch->push(currentNeed);
				currentNeed = ']';
				break;
			case '(':	// 开括号
				if (currentNeed != 0) pMatch->push(currentNeed);
				currentNeed = ')';
				break;
			default:	// 若当前扫描到的是：非待匹配的闭括号，如：待匹配为`]`,扫描的是`)}>`
				cout << "No" << endl;
				return;	// 记得return
			}
		}
		else {
			char elem;
			pScan->pop(elem);
			if (pMatch->pop(currentNeed) == 0) currentNeed = 0;
			// 1. 通过pMatch更新当前待匹配括号
			// 2. pMatch为空时，需给当前待匹配括号置零
		}
	}
	if (pScan->stackEmpty()) cout << "Yes" << endl;
	else cout << "No" << endl;

	delete pScan;
	pScan = nullptr;
	delete pMatch;
	pMatch = nullptr;
	return;
}

int main() {
	char str[] = "[()]]"; //[(1+3)=(5-1)],[[()]
	bracketMatch(str);
}
```



#### 4-4 栈应用括号匹配二 (14:29)

法二：

```c
// myself 
void bracketMatch1(const char* str) {
	MyStack<char>* pMatch = new MyStack<char>(30);
	char currentNeed = 0;
	for (int i = 0; i < strlen(str); i++) {
		//若遇到非括号字符，则跳过当前循环
		//if (str[i] != '(' && str[i] != ')' && str[i] != '[' && str[i] != ']') continue;
        if (str[i] == currentNeed) {
			if (pMatch->pop(currentNeed) == 0) currentNeed = 0; 
				// 1. 通过pMatch更新当前待匹配括号
				// 2. pMatch为空时，需给当前待匹配括号置零
		}
		else {
			if (currentNeed != 0) pMatch->push(currentNeed);
			currentNeed = str[i] == '(' ? ')' : (str[i] == '[' ? ']' : 'k');
		}
	}
	pMatch->stackEmpty()&&currentNeed==0 ? cout << "Yes" << endl : cout << "No" << endl;
	delete pMatch;
	pMatch = nullptr;
}
```







## [数据结构探险-线性表篇](https://www.imooc.com/learn/651)

> 简介：本课程主要以顺序表和链表作为内容主体，详细讲述了顺序表及链表的实现原理，并手把手完成顺序表及链表的基本结构操作，课程的最后通过通讯录的经典实例进一步深化讲解较为复杂的链表，使学员可以将知识融会贯通以至于学以致用。



### 第1章 线性表的概念及工作原理

> 本章讲解了线性表的基本概念，主体内容及工作原理。

#### 1-1 课程概述 (06:57)



栈与队列都是一种特殊的操作受限的线性表，只允许在端点处进行插入和删除。二者的区别是：

- 栈只允许在表的一端进行插入和删除操作，是一种“后进先出”的线性表；
- 队列是允许在一端进行插入操作，在别一端进行删除和操作，是一种”先进先出“的线性表



线性表：n个数据元素的有限序列

- 顺序表（数组）：
  - 优势：访问速度快，搜索能力强（数组本身就有下标，与内存地址直接相关）

- 链表：静态链表、单链表、循环链表、双向链表

![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200318104021.png)

- 线性表的应用场景：通讯录、一元多项式
- 事不加倍，半都没有！

![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200318104046.png)



### 第2章 顺序表的基本操作实战

> 本章详细讲述了顺序表的基本操作，并通过编码对基本操作的实现思路逐一讲解

#### 2-1 顺序表编码说明 (06:05)

第`i`个元素：下标为`i-1`的元素

前驱：指定元素的前一个元素

后继：指定元素的后一个元素

顺序表的基础操作：创建、销毁、清空、判空、判满、获取长度、获取指定元素、定位、获取前驱、获取后继、删除元素、插入元素、遍历

```c
// C语言描述
struct List {};

typedef int Elem;

bool initList(List** list);   				// 创建线性表

void destroyList(List* list); 				// 销毁线性表

void clearList(List* list);  				// 清空线性表

bool listEmpty(List* list);					// 判断线性表是否为空

int listLength(List* list);  				// 获取线性表的长度

bool getElem(List* list, int i, Elem* e);	// 获取指定元素

int locateElem(List* list, Elem* e);		//寻找第一个满足e的数据元素的位序

bool priorElem(List* list, Elem* current, Elem* pre);	//获取指定元素的前驱

bool nextElem(List* list, Elem* current, Elem* next);	//获取指定元素的后继

bool listInsert(List* list, int i, Elem* e);			//在第i个位置插入元素

bool listDelete(List* list, int i, Elem* e);			//删除第i个位置的元素

void listTraverse(List* list);							//遍历线性表
```



#### 2-2 顺序表编码实战（一） (07:51)

##### MyList--顺序表类

```c
//MyList.h
#pragma once
typedef int Elem;
class MyList {
public:
	MyList(int _size);
	~MyList();
	void clearList();
	bool listEmpty();
	int listLength();
	bool getElem(int i, Elem* e);		//把下标为i的元素 赋值给e指向的内存
	int locateElem(Elem* e);			//返回 值为*e的元素的 下标
	bool priorElem(Elem* e, Elem* pre);	//把 值为*e的元素的 前驱 赋值给pre指向的内存
	bool nextElem(Elem* e, Elem* next);	//把 值为*e的元素的 后继 赋值给next指向的内存
	bool insertElem(int i, Elem* e);
	bool deleteElem(int i, Elem* e);
	void listTraverse();
private:
	int* m_pList;
	int m_iSize;
	int m_iLength;
};
```

```c
//MyList.cpp
#include "MyList.h"
#include <iostream>
using namespace std;

MyList::MyList(int _size) {
	m_iSize = _size;
	m_pList = new int[m_iSize];
	m_iLength = 0;
}

MyList::~MyList() {
	delete[] m_pList;
}

void MyList::clearList() {
	m_iLength = 0;
}

bool MyList::listEmpty() {
	return m_iLength == 0 ? true : false;
}

int MyList::listLength() {
	return m_iLength;
}

bool MyList::getElem(int i, Elem* e) {
	if (i < 0 || i >= m_iSize) return false;
	*e = m_pList[i];
	return true;
}

int MyList::locateElem(Elem* e) {
	for (int i = 0; i < m_iLength; i++) {
		if (m_pList[i] == *e) return i;
	}
	return -1;
}

bool MyList::priorElem(Elem* e, Elem* pre) {
	int index = locateElem(e);
	if (-1 == index || 0 == index) return false;
	*pre = m_pList[index - 1];
	return true;
}

bool MyList::nextElem(Elem* e, Elem* next) {
	int index = locateElem(e);
	if (-1 == index || m_iLength - 1 == index) return false;
	*next = m_pList[index + 1];
	return true;
}

bool MyList::insertElem(int i, Elem* e) {
	if (i < 0 || i>m_iLength || m_iLength == m_iSize) 		
        // 共m_iLength个元素，可在下标为m_iLength的位置插入
        return false;		
	for (int k = m_iLength - 1; k >= i; k--) {	//插入位置及之后的元素都要往后移一次
		m_pList[k + 1] = m_pList[k];
	}
	m_pList[i] = *e;
	m_iLength++;		// 已有元素个数+1
	return true;
}

bool MyList::deleteElem(int i, Elem* e) {
	if (i < 0 || i >= m_iLength)	
        // 共m_iLength个元素，不可在下标为m_iLength的位置删除	
        return false;	
	*e = m_pList[i];
	for (int k = i + 1; k < m_iLength; k++) {
		m_pList[k - 1] = m_pList[k];
	}
	m_iLength--;
	return true;
}

void MyList::listTraverse() {
	for (int i = 0; i < m_iLength; i++) {
		cout << m_pList[i] << ' ';
	}
}
```



#### 2-3 顺序表编码实战（二） (10:41)

```c
// demo.cpp
#include <iostream>
#include "MyList.h"
using namespace std;
int main() {
	//3 5 7 2 9 1 8
	int e0 = 3, e1 = 5, e2 = 7, e3 = 2, e4 = 9, e5 = 1, e6 = 8;
	MyList* li = new MyList(10);
	cout << "Length: " << li->listLength() << endl;
	li->insertElem(0, &e0);
	li->insertElem(1, &e1);
	li->insertElem(2, &e2);
	li->insertElem(3, &e3);
	li->insertElem(4, &e4);
	li->insertElem(5, &e5);
	li->insertElem(3, &e6);	//插入到下标3的位置
	li->listTraverse();
	cout << "Length: " << li->listLength() << endl;

	int temp = 0;
	li->deleteElem(0, &temp);
	cout << temp << endl;
	li->listTraverse();

	li->clearList();
	li->listTraverse();

	delete li;
	li = nullptr;
}
```



#### 2-4 顺序表编码实战（三） (12:16)

```c
// demo.cpp
#include <iostream>
#include "MyList.h"
using namespace std;
int main() {
	//3 5 7 2 9 1 8
	int e0 = 3, e1 = 5, e2 = 7, e3 = 2, e4 = 9, e5 = 1, e6 = 8;
	MyList* li = new MyList(10);
	li->insertElem(0, &e0);
	li->insertElem(1, &e1);
	li->insertElem(2, &e2);
	li->insertElem(3, &e3);
	li->insertElem(4, &e4);
	li->insertElem(5, &e5);
	li->insertElem(6, &e6);
	li->listTraverse();

	int temp = 0;
	li->getElem(0, &temp);
	cout << "temp:" << temp << endl;
	li->getElem(4, &temp);
	cout << "temp:" << temp << endl;
	cout << "index of temp:" << li->locateElem(&temp) << endl;

	li->priorElem(&e2,&temp);
	cout << "temp:" << temp << endl;
	li->nextElem(&e2,&temp);
	cout << "temp:" << temp << endl;

	delete li;
	li = nullptr;
}
```



#### 2-5 顺序表编码实战（四） (14:08)

##### MyList--顺序表类模板

```c
// MyList.h
#pragma once
#include <iostream>
using namespace std;

template<typename Elem>
class MyList {
public:
	MyList(int _size);
	~MyList();
	void clearList();
	bool listEmpty();
	int listLength();
	bool getElem(int i, Elem* e);
	int locateElem(Elem* e);
	bool priorElem(Elem* e, Elem* pre);
	bool nextElem(Elem* e, Elem* next);
	bool insertElem(int i, Elem* e);
	bool deleteElem(int i, Elem* e);
	void listTraverse();
private:
	Elem* m_pList;
	int m_iSize;
	int m_iLength;
};

template<typename Elem>
MyList<Elem>::MyList(int _size) {
	m_iSize = _size;
	m_pList = new Elem[m_iSize];
	m_iLength = 0;
}
template<typename Elem>
MyList<Elem>::~MyList() {
	delete[] m_pList;
}
template<typename Elem>
void MyList<Elem>::clearList() {
	m_iLength = 0;
}
template<typename Elem>
bool MyList<Elem>::listEmpty() {
	return m_iLength == 0 ? true : false;
}
template<typename Elem>
int MyList<Elem>::listLength() {
	return m_iLength;
}
template<typename Elem>
bool MyList<Elem>::getElem(int i, Elem* e) {
	if (i < 0 || i >= m_iSize) return false;
	*e = m_pList[i];
	return true;
}
template<typename Elem>
int MyList<Elem>::locateElem(Elem* e) {
	for (int i = 0; i < m_iLength; i++) {
		if (m_pList[i] == *e) return i;
	}
	return -1;
}
template<typename Elem>
bool MyList<Elem>::priorElem(Elem* e, Elem* pre) {
	int index = locateElem(e);
	if (-1 == index || 0 == index) return false;
	*pre = m_pList[index - 1];
	return true;
}
template<typename Elem>
bool MyList<Elem>::nextElem(Elem* e, Elem* next) {
	int index = locateElem(e);
	if (-1 == index || m_iLength - 1 == index) return false;
	*next = m_pList[index + 1];
	return true;
}
template<typename Elem>
bool MyList<Elem>::insertElem(int i, Elem* e) {
	if (i < 0 || i>m_iLength || m_iLength == m_iSize)		
        // 共m_iLength个元素，可在下标为m_iLength的位置插入
        return false;		
	for (int k = m_iLength - 1; k >= i; k--) {	//插入位置及之后的元素都要往后移一次
		m_pList[k + 1] = m_pList[k];
	}
	m_pList[i] = *e;
	m_iLength++;		//已有元素个数+1
	return true;
}
template<typename Elem>
bool MyList<Elem>::deleteElem(int i, Elem* e) {
	if (i < 0 || i >= m_iLength)
        return false;	
	*e = m_pList[i];
	for (int k = i + 1; k < m_iLength; k++) {
		m_pList[k - 1] = m_pList[k];
	}
	m_iLength--;
	return true;
}
template<typename Elem>
void MyList<Elem>::listTraverse() {
	for (int i = 0; i < m_iLength; i++) {
		cout << m_pList[i] << ' ';
	}
}
```

##### 使用

> [Coordinate--坐标类](#Coordinate--坐标类)

```c
#include <iostream>
#include "MyList.h"
#include "Coordinate.h"
using namespace std;
int main() {
	Coordinate e0 = { 3,2 }, e1 = 5, e2 = 7, e3 = 2, e4 = 9, e5 = 1, e6 = 8;
	MyList<Coordinate>* li = new MyList<Coordinate>(10);
	li->insertElem(0, &e0);
	li->insertElem(1, &e1);
	li->insertElem(2, &e2);
	li->insertElem(3, &e3);
	li->insertElem(4, &e4);
	li->insertElem(5, &e5);
	li->insertElem(6, &e6);	//插入到下标3的位置
	li->listTraverse();

	Coordinate temp = 0;
	li->getElem(0, &temp);
	cout << "temp:" << temp << endl;
	li->getElem(4, &temp);
	cout << "temp:" << temp << endl;
	cout << "index of temp:" << li->locateElem(&temp) << endl;

	li->priorElem(&e2,&temp);
	cout << "temp:" << temp << endl;
	li->nextElem(&e2,&temp);
	cout << "temp:" << temp << endl;

	delete li;
	li = nullptr;
}
```

2-6 顺序表编码实战（五） (08:21)

2-7 顺序表编码实战（六） (04:14)

2-8 顺序变编码实战（七） (05:21)

2-9 顺序表编码实战（八） (11:08)



### 第3章 链表的基本操作实战

> 本章详细讲述了链表的基本操作，并通过编码对基本操作的实现思路逐一讲解。
>

#### 3-1 链表算法说明 (06:21)

为什么有了顺序表还需要链表，因为两者互为补充

顺序表的优缺点：

- 优点：遍历和寻址时非常方便（因为基于数组）

- 缺点：插入删除元素

链表：结点（即元素）=数据域+指针域

> 节点相当于结构体(struct)
>
> 尾结点特征：指针域为NULL

- 【单链表】头结点->结点…->NULL 

![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200318162055.png)

- 【循环链表】头结点->结点…->尾结点->头结点

![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200318162126.png)

- 【双向链表】结点=指针域A（正向）+ 数据域 + 指针域B（反向）

![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200318162222.png)

有些编程语言没有指针：通过数组实现

- 【静态链表】结点=“指针域”+数据域。（数组本身具有天然的编号）
  - 数组中第一个位置代表静态链表的头节点
  - “指针”=0，链表结束了

![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200318162247.png)



#### 3-2 链表编码说明 (09:21)

##### Node--节点类

```c
//Node.h
#pragma once
class Node {
public:
	//数据域和指针域都为public，方便赋值。不需要再定义对数据域和指针域的操作函数
	int data;
	Node* next;
	void printNode();
};
```

```c
//Node.cpp
#include "Node.h"
#include <iostream>
using namespace std;

void Node::printNode() {
	cout << data << endl;
}
```



#### 3-3 链表编码实战（一） (06:01)

> 哨兵节点（sentinel）是一个哑元节点（dummy node），可以简化边界条件。是一个附加的链表节点，该节点作为第一个节点，它的值域中并不存储任何东西，只是为了操作的方便而引入的。如果一个链表有哨兵节点的话，那么线性表的第一个元素应该是链表的第二个节点。

这里把头节点当作是一个[哨兵节点](https://www.zhihu.com/question/27155932)

- 头节点数据域无意义
- 头节点并不算在链表的长度当中

销毁链表与清空链表的区别

- `~List();，`删除所有节点

- `clearList();` 第一个节点留下，其余所有节点删除掉

 

#### 3-4 链表编码实战（二） (06:39)

`bool insertElem();`如果直接将传入的结点作为链表中新添加的结点内存，是不安全的。

- 因为传入的结点内存是有可能在链表外被释放掉的，如果被释放掉，则链表就会断开失效；
- 而申请一个新的结点内存作为链表的结点内存，则该内存只有在链表中才可以被释放掉，这样保证了链表内存是安全释放的

`bool PriorElem();`两种情况为没有前驱：

- 节点为头结点
- 节点在链表中无法找到

#### 3-5 链表编码实战（三） (06:52)

##### MyList--链表类模板

> 其实没必要用类模板，因为链表里的元素一定是节点。除非有不同实现的节点

```c
// MyList.h
#pragma once
#include <iostream>
using namespace std;

template<typename Elem>
class MyList {
public:
	MyList();
	~MyList();
	void clearList();
	bool listEmpty();
	int listLength();
	bool getElem(int i, Elem* e);
	int locateElem(Elem* e);
	bool priorElem(Elem* e, Elem* pre);
	bool nextElem(Elem* e, Elem* next);
	bool insertElem(int i, Elem* e);
	bool deleteElem(int i, Elem* e);
	void listTraverse();
	//ListInsertHead是在头节点后面插入一个节点，而不是在头节点的前面插入一个节点来替换掉原本的头节点
	bool insertHead(Elem* e);
	bool insertTail(Elem* e);
private:
	Elem* m_pList;	//对象(元素)指针，指向头节点
	int m_iLength;
};

template<typename Elem>
MyList<Elem>::MyList() {
	m_pList = new Elem;		//头节点
	m_pList->data = 0;		//无意义， 可去掉
	m_pList->next = nullptr;
	m_iLength = 0;
}
template<typename Elem>
MyList<Elem>::~MyList() {
	clearList();
	delete m_pList;
}

template<typename Elem>
void MyList<Elem>::clearList() {
	Elem* currentElem = m_pList->next;
	while (currentElem != nullptr) {	//当前节点非空
		Elem* temp = currentElem->next;	//盘问当前节点的下个节点
		delete currentElem;				//干掉当前节点
		currentElem = temp;				//去找下个节点
	}
	m_pList->next = nullptr;			//头节点指NULL
	m_iLength = 0;
}
template<typename Elem>
bool MyList<Elem>::listEmpty() {
	return m_iLength == 0 ? true : false;
}
template<typename Elem>
int MyList<Elem>::listLength() {
	return m_iLength;
}

template<typename Elem>
bool MyList<Elem>::getElem(int i, Elem* e) {
	if (i < 0 || i >= m_iLength) return false;
	Elem* currentElem = m_pList;		// 从头节点前进一次，到底下标为 0 的节点
	for (int k = 0; k <= i; k++) {		// 前进了 i+1 次，到达下标为 i 的节点
		currentElem = currentElem->next;
	}
	e->data = currentElem->data;
	return true;
}

template<typename Elem>
int MyList<Elem>::locateElem(Elem* e) {
	Elem* currentElem = m_pList;
	int count = 0;
	while (currentElem->next != nullptr) {
		currentElem = currentElem->next;
		if (currentElem->data == e->data)
			return count;
		count++;
	}
	return -1;
}

template<typename Elem>
bool MyList<Elem>::priorElem(Elem* e, Elem* pre) {
	Elem* currentElem = m_pList;
	Elem* currentPre = nullptr;
	while (currentElem->next != nullptr) {
		currentPre = currentElem;		//保存前一个节点
		currentElem = currentElem->next;
		if (currentElem->data == e->data) {
			if (currentPre == m_pList)	//前驱不能是头节点
				return false;
			pre->data = currentPre->data;
			return true;
		}
	}
	return false;
}

template<typename Elem>
bool MyList<Elem>::nextElem(Elem* e, Elem* next) {
	Elem* currentElem = m_pList;
	while (currentElem->next != nullptr) {
		currentElem = currentElem->next;
		if (currentElem->data == e->data) {
			if (currentElem->next == nullptr) //后继不能是尾结点
				return false;
			next->data = currentElem->next->data;
			return true;
		}
	}
	return false;
}

template<typename Elem>
bool MyList<Elem>::insertElem(int i, Elem* e) {
	if (i < 0 || i>m_iLength) return false;	//共m_iLength个元素，可在下标为m_iLength的位置插入
	Elem* currentElem = m_pList;	//当前节点为头节点
	for (int k = 0; k < i; k++) {	//头节点的next节点下标为0，即第一个有意义的节点。
		currentElem = currentElem->next;
	}
	Elem* newElem = new Elem;		//申请一个新的结点内存
	if (nullptr == newElem)
		return false;
	newElem->data = e->data;
	newElem->next = currentElem->next;
	currentElem->next = newElem;
	m_iLength++;		//已有元素个数+1
	return true;
}

template<typename Elem>
bool MyList<Elem>::deleteElem(int i, Elem* e) {
	if (i < 0 || i >= m_iLength) return false;	//共m_iLength个元素，不可在下标为m_iLength的位置删除
	Elem* currentElem = m_pList;
	for (int k = 0; k < i; k++) {
		currentElem = currentElem->next;
	}
	e->data = currentElem->next->data;			//拷贝待删除节点数据
	Elem* deletedElem = currentElem->next;		//指定待删除节点
	currentElem->next = currentElem->next->next;
	delete deletedElem;
	deletedElem = nullptr;
	m_iLength--;
	return true;
}

template<typename Elem>
void MyList<Elem>::listTraverse() {
	Elem* currentElem = m_pList;
	while (currentElem->next != nullptr) {
		currentElem = currentElem->next;
		currentElem->printNode();
	}
}

//这种方式只需要e的数据域,而不关心其指针域。即：传参的节点只取了其中的数据
template<typename Elem>
inline bool MyList<Elem>::insertHead(Elem* e) {
	//一定要从堆中申请内存，如果从栈中申请内存则，那么这个函数执行完后会内存又会被回收掉
	Elem* newElem = new Elem;
	if (nullptr == newElem)
		return false;
	newElem->data = e->data;
	newElem->next = m_pList->next;
	m_pList->next = newElem;
	m_iLength++;
	return true;
}

template<typename Elem>
inline bool MyList<Elem>::insertTail(Elem* e) {
	Elem* currentElem = m_pList;
	while (currentElem->next != nullptr) currentElem = currentElem->next;
	Elem* newElem = new Elem;
	if (nullptr == newElem)
		return false;
	newElem->data = e->data;
	newElem->next = nullptr;
	currentElem->next = newElem;
	m_iLength++;
	return true;
}
```

##### 使用

```c
// demo.cpp
#include <iostream>
#include "MyList.h"
#include "Node.h"
#include "world.h"
using namespace std;
int main() {
	Node n1; n1.data = 3;
	Node n2; n2.data = 4;
	Node n3; n3.data = 5;
	Node n4; n4.data = 6;
	Node n5; n5.data = 7;
	Node temp;
	MyList<Node>* li = new MyList<Node>;

	//li->insertHead(&n1);
	//li->insertHead(&n2);
	//li->insertHead(&n3);
	//li->insertHead(&n4);
	li->insertTail(&n1);
	li->insertTail(&n2);
	li->insertTail(&n3);
	li->insertTail(&n4);
	li->listTraverse();

	li->insertElem(1, &n5);
	//li->deleteElem(1, &temp);
	//li->getElem(1, &temp);
	//li->priorElem(&n5, &temp);
	li->nextElem(&n5, &temp);
	cout << "temp: "<<temp.data << endl;
	delete li;
	li = nullptr;
}
```

3-6 链表编码实战（四） (11:27)
3-7 链表编码实战（五） (08:56)
3-8 链表编码实战（六） (10:07)
3-9 链表编码实战（七） (15:55)



### 第4章 链表应用-通讯录

> 本章讲述了链表的经典应用通讯录的实现原理及编码技巧。

#### 4-1 线性表应用之通讯录（一） (11:00)

##### Node--节点类模板

```c
#pragma once
#include <iostream>
using namespace std;
template<typename T>
class Node {
public:
	//数据域和指针域都为public，方便赋值。不需要再定义对数据域和指针域的操作函数
	T data;
	Node* next;
	void printNode();
};
template<typename T>
void Node<T>::printNode() {
	cout << data << endl;
}
```

##### Person--人类

```c
//Person.h
#pragma once
#include <string>
#include<iostream>
using namespace std;
class Person {
	friend ostream& operator<<(ostream& out, const Person& p);
public:
	Person(string _name = "", string _phone = "");
    	// 必须有默认构造函数，因为 m_pList = new Elem;
	Person& operator=(Person& p);
	bool operator==(Person& p);
private:
	string name;
	string phone;
};
```

```c
//Person.cpp
#include "Person.h"

Person::Person(string _name, string _phone)
	:name(_name), phone(_phone)
{}

Person& Person::operator=(Person& p) {
	name = p.name;
	phone = p.phone;
	return *this;
}

bool Person::operator==(Person& p) {
	return name == p.name && phone == p.phone ? true : false;
}

ostream& operator<<(ostream& out, const Person& p) {
	out << p.name << "\t------\t" << p.phone;
	return out;
}
```

##### 使用

```c
#include <iostream>
#include "MyList.h"
#include "Node.h"
#include "Person.h"
using namespace std;
int main() {
	Node<Person> n1 = { {"Younger","89"} };
	Node<Person> n2 = { {"Tary","62"} };
	Node<Person> n3 = { {"Lipoy","16"} };
	Node<Person> n4 = { {"Bob","3"} };
	Node<Person> n5 = { {"流放","90"} };
	Node<Person> temp;
	MyList<Node<Person>>* li = new MyList<Node<Person>>;
	li->insertHead(&n1);
	li->insertHead(&n2);
	li->insertHead(&n3);
	li->insertHead(&n4);
	//li->insertTail(&n1);
	//li->insertTail(&n2);
	//li->insertTail(&n3);
	//li->insertTail(&n4);
	li->listTraverse();
	delete li;
	li = nullptr;
}
```



#### 4-2 线性表应用之通讯录（二） (08:52)

##### 通讯录

```c
#include <iostream>
#include "MyList.h"
#include "Node.h"
#include "Person.h"
using namespace std;
int menu() {
	cout << "功能菜单" << endl;
	cout << "1 新建联系人" << endl;
	cout << "2 删除联系人" << endl;
	cout << "3 浏览通讯录" << endl;
	cout << "4 退出通讯录" << endl;
	cout << "请输入：";
	int order = 0;
	cin >> order;
	return order;
}
void creatPerson(MyList<Node<Person>>* li) {
	string pName, pNum;
	cout << "请输入姓名：";
	cin >> pName;
	cout << "请输入电话：";
	cin >> pNum;
	Node<Person> no{ {pName, pNum } };
	li->insertTail(&no);
}
void deletePerson(MyList<Node<Person>>* li) {
	li->listTraverse();
	int i;
	Node<Person> p;
	cout << "请输入待删除联系人序号:";
	cin >> i;
	li->deleteElem(i - 1, &p);
}
int main() {
	int userOrder = 0;
	MyList<Node<Person>>* pli = new MyList<Node<Person>>;
	while (userOrder != 4) {
		userOrder = menu();
		switch (userOrder) {
		case 1:
			cout << endl << "用户指令 ----> 新建联系人" << endl;
			creatPerson(pli);
			break;
		case 2:
			cout << endl << "用户指令 ----> 删除联系人" << endl;
			deletePerson(pli);
			break;
		case 3:
			cout << endl << "用户指令 ----> 浏览通讯录" << endl;
			pli->listTraverse();
			break;
		case 4:
			cout << endl << "用户指令 ----> 退出通讯录" << endl;
			break;
		}
		cout << endl;
	}
	return 0;
}
```







## [数据结构探险-树篇](https://www.imooc.com/learn/673)

> 简介：课程从树的实现原理角度讲解了树的相关概念，着重讲解了二叉树三种遍历方式的原理，并通过编码实践，进一步说明二叉树使用数组和链表方式的编程技巧，以及前序遍历、中序遍历和后序遍历递归实现



### 第1章 树的基本概念

> 树的基本概念

#### 1-1 1. 树的基本概念 (10:11)

[parent ancestor]

[child descendant]

【树】节点的有限集合

【度】[degree] : 当前节点的直接孩子数目。

【叶子】[leaf] : 终端节点

[root] : 非终端节点名？

【无序树】同一节点的几个子节点可以随便换顺序而不影响逻辑

![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200319201737.png)

【深度】

- 节点深度（即层的深度）

- 树的深度（所有层里节点的最大深度）

- 根结点的深度为 1

  ![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200319202153.png)

【二叉树】所有节点的度<=2的树

【用途】压缩软件-赫夫曼树、搜索-人机对战

【二叉树的遍历】：前序遍历、中序、后序

- 前中后是相对于根节点来说的，先访问根节点就是前序，以此类推
- **左子树**一定先于**右子树**访问

前序遍历：根左右
中序遍历：左根右
后序遍历：左右根

![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200319200923.png)



### 第2章 二叉树数组实现编码说明

> 二叉树数组实现编码说明

#### 2-1 二叉树数组实现编码说明 

> 我们在构建树的时候一般都不会用数组，因为我们一开始不会知道树有多少个节点，用数组的话我们是一开始就声明一段连续的内存。
>
> 用指针的话方便添加新节点，节点与节点之间不需要是连续的内存，只需要在建立新节点的时候把指针指向父节点即可，方便对树进行添加与删除的操作。

数组表达二叉树

- 没有节点的地方用0表示

- 父节点的左孩子节点的下标为：父节点`index*2+1`
- 父节点的右孩子节点的下标为：父节点`index*2+2`

添加节点：把nodeIndex当成父节点，为其添加子节点

```c
// C语言描述
/* 	1.树的创建与销毁
	2.树中节点的搜索
	3.树中节点的添加和删除
	4.树中节点的遍历
	int tree[] = { 3,5,8,2,6,9,7 };
		
                3(0)
        5(1)		   8(2)
    2(3)	6(4)	9(5)	7(6)

*/    
 
bool createTree(Tree** pTree, Node* pRoot);							//创建树
void destroyTree(Tree* pTree);										//销毁树
Node* searchNode(Tree* pTree, int nodeIndex);						//根据索引寻找节点
bool addNode(Tree* pTree, int nodeIndex,int direction, Node* pNode);//添加节点
bool deleteNode(Tree* pTree, int nodeIndex, Node* pNode);			//删除节点
void treeTraverse(Tree* pTree);										//遍历
```



### 第3章 二叉树数组实现编码实战

> 二叉树数组实现编码实战

#### 3-1 二叉树数组实现（一）

##### Tree--二叉树类

```c
// Tree.h
#pragma once
#include <iostream>
using namespace std;
class Tree {
public:
	Tree(int size, int* pRoot);	//addNode无法添加头节点*pRoot，所以得初始化
	~Tree();
	int* searchNode(int nodeIndex);
	bool addNode(int nodeIndex, int direction, int* pNode);
	bool deleteNode(int nodeIndex, int* pNode);
	void treeTraverse();
private:
	int* m_pTree;
	int m_iSize;
};
```

```c
// Tree.cpp
#include "Tree.h"

Tree::Tree(int size, int* pRoot) {
	m_iSize = size;
	m_pTree = new int[size]();	//值初始化，对内置类型即为零初始化
	m_pTree[0] = *pRoot;
}

Tree::~Tree() {
	delete[]m_pTree;
}

int* Tree::searchNode(int nodeIndex) {
	if (nodeIndex < 0 || nodeIndex >= m_iSize)
		return nullptr;
	if (0 == m_pTree[nodeIndex])
		return nullptr;
	return &m_pTree[nodeIndex];
}

bool Tree::addNode(int nodeIndex, int direction, int* pNode) {
	if (nodeIndex < 0 || nodeIndex >= m_iSize)
		return false;
	if (0 == m_pTree[nodeIndex])	//该位置不存在节点
		return false;
	if (0 == direction) {
		if (nodeIndex * 2 + 1 >= m_iSize) return false;
		if (0 != m_pTree[nodeIndex * 2 + 1]) return false;	//该位置已经存在节点
		m_pTree[nodeIndex * 2 + 1] = *pNode;
	}
	if (1 == direction) {
		if (nodeIndex * 2 + 2 >= m_iSize) return false;
		if (0 != m_pTree[nodeIndex * 2 + 2]) return false;	//该位置已经存在节点
		m_pTree[nodeIndex * 2 + 2] = *pNode;
	}
	return true;
}

bool Tree::deleteNode(int nodeIndex, int* pNode) {	//递归删除子节点
	if (nodeIndex < 0 || nodeIndex >= m_iSize)
		return false;
	if (0 == m_pTree[nodeIndex])	//该位置不存在节点
		return false;
	static int* pOrigin = pNode;	//只初始化一次，递归调用不改变其值
	*pNode = m_pTree[nodeIndex];
	m_pTree[nodeIndex] = 0;
	deleteNode(2 * nodeIndex + 1, pOrigin + 2 * (pNode - pOrigin) + 1);
	deleteNode(2 * nodeIndex + 2, pOrigin + 2 * (pNode - pOrigin) + 2);
	return true;
}

void Tree::treeTraverse() {		//树状结构遍历
	int i = 0;
	int k = 1;
	while (m_iSize > i) {
		for (int j = i; j < i + k; j++) {	// 每次输出k个
			cout << m_pTree[j] << " ";
		}
		cout << endl;
		i += k;
		k = (m_iSize >= i + 2 * k) ? (2 * k) : (m_iSize - i);
	}
}
```


```c
// demo.cpp
#include <iostream>
#include "Tree.h"
using namespace std;
void treeTraverse(int m_iSize, int* m_pTree) {
	int i = 0;
	int k = 1;
	while (m_iSize > i) {
		for (int j = i; j < i + k; j++) {
			cout << m_pTree[j] << " ";
		}
		cout << endl;
		i += k;
		k = (m_iSize >= i + 2 * k) ? (k * 2) : (m_iSize - i);
	}
}
int main() {
	int root = 3;
	int n1 = 5, n2 = 8, n3 = 2, n4 = 6, n5 = 9, n6 = 7;
	Tree* t = new Tree(10, &root);
	t->addNode(0, 0, &n1);
	t->addNode(0, 1, &n2);
	t->addNode(1, 0, &n3);
	t->addNode(1, 1, &n4);
	t->addNode(2, 0, &n5);
	t->addNode(2, 1, &n6);
	t->treeTraverse();

	int* pN = t->searchNode(2);
	cout << endl << "Node=" << *pN << endl;

	int temp[10]{ 0 };
	t->deleteNode(2, temp);
	treeTraverse(10, temp);

	t->treeTraverse();
	delete t;
	t = nullptr;
}
```



#### 3-2 二叉树数组实现（二）

##### Tree--二叉树类模板

```c
#pragma once
#include <iostream>
using namespace std;
template<typename T>
class Tree {
public:
	Tree(int size, T* pRoot);
	~Tree();
	T* searchNode(int nodeIndex);
	bool addNode(int nodeIndex, int direction, T* pNode);
	bool deleteNode(int nodeIndex, T* pNode);
	void treeTraverse();
private:
	struct pack { T data; bool validity; } *m_pTree;		
    	// 用一个结构体封装：T类型数据和bool类型变量(定义该节点是否有意义)
	int m_iSize;
};

template<typename T>
Tree<T>::Tree(int size, T* pRoot) {
	m_iSize = size;
	m_pTree = new pack[size]();	//值初始化
	m_pTree[0].data = *pRoot;
	m_pTree[0].validity = true;
}

template<typename T>
Tree<T>::~Tree() {
	delete[]m_pTree;
}

template<typename T>
T* Tree<T>::searchNode(int nodeIndex) {
	if (nodeIndex < 0 || nodeIndex >= m_iSize)
		return nullptr;
	if (false == m_pTree[nodeIndex].validity)	//无意义，即该位置不存在节点
		return nullptr;
	return &(m_pTree[nodeIndex].data);
}

template<typename T>
bool Tree<T>::addNode(int nodeIndex, int direction, T* pNode) {
	if (nodeIndex < 0 || nodeIndex >= m_iSize)
		return false;
	if (false == m_pTree[nodeIndex].validity)
		return false;
	if (0 == direction) {
		if (nodeIndex * 2 + 1 >= m_iSize) return false;
		if (true == m_pTree[nodeIndex * 2 + 1].validity) return false;	//该位置已经存在节点
		m_pTree[nodeIndex * 2 + 1].data = *pNode;
		m_pTree[nodeIndex * 2 + 1].validity = true;	//使该节点有效
	}
	if (1 == direction) {
		if (nodeIndex * 2 + 2 >= m_iSize) return false;
		if (true == m_pTree[nodeIndex * 2 + 2].validity) return false;	//该位置已经存在节点
		m_pTree[nodeIndex * 2 + 2].data = *pNode;
		m_pTree[nodeIndex * 2 + 2].validity = true;	//使该节点有效
	}
	return true;
}

template<typename T>
bool Tree<T>::deleteNode(int nodeIndex, T* pNode) {
	if (nodeIndex < 0 || nodeIndex >= m_iSize)
		return false;
	if (false == m_pTree[nodeIndex].validity)	
		return false;
	static T* pOrigin = pNode;				//只初始化一次，递归调用不改变其值
	*pNode = m_pTree[nodeIndex].data;
	m_pTree[nodeIndex].validity = false;	//使该节点无效
	deleteNode(2 * nodeIndex + 1, pOrigin + 2 * (pNode - pOrigin) + 1);
	deleteNode(2 * nodeIndex + 2, pOrigin + 2 * (pNode - pOrigin) + 2);
	return true;
}

template<typename T>
void Tree<T>::treeTraverse() {
	int sizeOfData = sizeof(m_pTree[0].data) / 4; //待改进
	int i = 0;
	int k = 1;
	while (m_iSize > i) {
		for (int j = i; j < i + k; j++) {
			if (true == m_pTree[j].validity)
				cout << m_pTree[j].data << " ";
			//else cout << string(sizeOfData, '*') << " ";
			else cout << pack().data << "*";
		}
		cout << endl;
		i += k;
		k = (m_iSize >= i + 2 * k) ? (k * 2) : (m_iSize - i);
	}
}
```

##### 使用1

```c
#include <iostream>
#include "Tree.h"
using namespace std;
void treeTraverse(int m_iSize, int* m_pTree) {
	int i = 0;
	int k = 1;
	while (m_iSize > i) {
		for (int j = i; j < i + k; j++) {
			cout << m_pTree[j] << " ";
		}
		cout << endl;
		i += k;
		k = (m_iSize >= i + 2 * k) ? (k * 2) : (m_iSize - i);
	}
}
int main() {
	int root = 3;
	int n1 = 5, n2 = 8, n3 = 2, n4 = 6, n5 = 9, n6 = 7;
	Tree<int>* t = new Tree<int>(10, &root);
	t->addNode(0, 0, &n1);
	t->addNode(0, 1, &n2);
	t->addNode(1, 0, &n3);
	t->addNode(1, 1, &n4);
	t->addNode(2, 0, &n5);
	t->addNode(2, 1, &n6);
	t->treeTraverse();

	int* pN = t->searchNode(2);
	cout << endl << "Node=" << *pN << endl;

	int temp[10]{ 0 };
	t->deleteNode(1, temp);
	treeTraverse(10, temp);

	t->treeTraverse();
	delete t;
	t = nullptr;
}
```

##### 使用2

> [Coordinate--坐标类](#Coordinate--坐标类)

```c
#include <iostream>
#include "Tree.h"
#include "Coordinate.h"
using namespace std;
template<typename T>
void treeTraverse(int m_iSize, T* m_pTree) {
	int i = 0;
	int k = 1;
	while (m_iSize > i) {
		for (int j = i; j < i + k; j++) {
			cout << m_pTree[j] << " ";
		}
		cout << endl;
		i += k;
		k = (m_iSize >= i + 2 * k) ? (k * 2) : (m_iSize - i);
	}
}
int main() {
	Coordinate root = { 3,2 }, n1 = 5, n2 = 7, n3 = 2, n4 = 9, n5 = 1, n6 = 8;
	Tree<Coordinate>* t = new Tree<Coordinate>(10, &root);
	t->addNode(0, 0, &n1);
	t->addNode(0, 1, &n2);
	t->addNode(1, 0, &n3);
	t->addNode(1, 1, &n4);
	t->addNode(2, 0, &n5);
	t->addNode(2, 1, &n6);
	t->treeTraverse();

	Coordinate* pN = t->searchNode(2);
	cout << endl << "Node=" << *pN << endl << endl;

	Coordinate temp[10]{ 0 };
	t->deleteNode(1, temp);
	treeTraverse(10, temp);
	cout << endl;

	t->treeTraverse();
	delete t;
	t = nullptr;
}

// 输出
(3,2)
(5,0) (7,0)
(2,0) (9,0) (1,0) (8,0)
(0,0)*(0,0)*(0,0)*

Node=(7,0)
    
(5,0)
(2,0) (9,0)
(0,0) (0,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
    
(3,2)
(0,0)*(7,0)
(0,0)*(0,0)*(1,0) (8,0)
(0,0)*(0,0)*(0,0)*
```



第4章 二叉树链表实现编码说明

> 二叉树链表实现编码说明

4-1 二叉树链表实现编码说明

第5章 二叉树数组实现原理演示

> 二叉树数组实现原理演示

5-1 二叉树数组实现原理演示



### 第6章 叉树编码实战

> 叉树编码实战

#### 6-1 二叉树编码实战（一） (06:06)

销毁树依赖于删除结点，删除结点依赖于搜索结点，添加结点依赖于搜索结点

> 在实现各个成员函数的时候，要结合它们的内在联系来决定实现顺序，像这里，当实现了搜索节点的函数后，其他的函数实现就简单多了。



##### TNode--节点类

```c
//TNode.h
#pragma once
#include <iostream>
using namespace std;
class TNode {
public:
	TNode(int _index = 0, int _data = 0);
	TNode* searchTNode(int nodeIndex);
	void deleteTNode();
	void preOrderTraversal();
	void inOrderTraversal();
	void postOrderTraversal();
	int index;
	int data;
	TNode* pLeft;
	TNode* pRight;
	TNode* pParent;
};

//TNode.cpp
#include "TNode.h"
#include <iostream>
using namespace std;

TNode::TNode(int _index, int _data) {
	index = _index;
	data = _data;
	pLeft = nullptr;
	pRight = nullptr;
	pParent = nullptr;
}

TNode* TNode::searchTNode(int nodeIndex) {					//TNode查找的范围是：该节点及其子树
	if (this->index == nodeIndex)
		return this;
	if (this->pLeft != nullptr)
		if (this->pLeft->searchTNode(nodeIndex) != nullptr)	//注意：找到了才能return
			return this->pLeft->searchTNode(nodeIndex);		//递归
	if (this->pRight != nullptr)
		if (this->pRight->searchTNode(nodeIndex) != nullptr)//可以不用这句判断，直接返回完事了。
			return this->pRight->searchTNode(nodeIndex);
	return nullptr;											//注意 找不到要 return NULL
}

void TNode::deleteTNode() {
	if (this->pLeft != nullptr)
		this->pLeft->deleteTNode();			//递归删除 左子树
	if (this->pRight != nullptr)
		this->pRight->deleteTNode();		//递归删除 右子树
	if (this->pParent != nullptr) {			//这个判断是考虑到根节点没有parent
		if (this->pParent->pLeft == this) {
			this->pParent->pLeft = nullptr;	//把父节点的指针置NULL
		}
		if (this->pParent->pRight == this) {
			this->pParent->pRight = nullptr;
		}
	}
	delete this;							//最后删除自己
}

void TNode::preOrderTraversal() {
	cout << this->index << ":" << this->data << endl;
	if (this->pLeft != nullptr)
		this->pLeft->preOrderTraversal();
	if (this->pRight != nullptr)
		this->pRight->preOrderTraversal();
}

void TNode::inOrderTraversal() {
	if (this->pLeft != nullptr)
		this->pLeft->inOrderTraversal();
	cout << this->index << ":" << this->data << endl;
	if (this->pRight != nullptr)
		this->pRight->inOrderTraversal();
}

void TNode::postOrderTraversal() {
	if (this->pLeft != nullptr)
		this->pLeft->postOrderTraversal();
	if (this->pRight != nullptr)
		this->pRight->postOrderTraversal();
	cout << this->index << ":" << this->data << endl;
}
```



##### Tree--二叉树类

```c
//Tree.h
#include "TNode.h"
#include <iostream>
using namespace std;
class Tree {
public:
	Tree();  							//创建树
	~Tree();                            //销毁树
	TNode* searchTNode(int nodeIndex);	//搜索结点
	bool addTNode(int nodeIndex, int direction, TNode* pTNode);	//添加结点
	bool deleteTNode(int nodeIndex, TNode* pTNode);				//删除结点
	void preOrderTraversal();//前序遍历
	void inOrderTraversal(); //中序遍历
	void postOrderTraversal();//后序遍历
private:
	TNode* m_pRoot;
};

//Tree.cpp
#include "Tree.h"

Tree::Tree() {
	m_pRoot = new TNode();
}

Tree::~Tree() {
	deleteTNode(0, nullptr);
	//or m_pRoot->deleteTNode();
}

//通过调用TNode的成员函数。Tree相当于代理类，TNode相当于实现类
TNode* Tree::searchTNode(int nodeIndex) {
	return m_pRoot->searchTNode(nodeIndex);
}

bool Tree::addTNode(int nodeIndex, int direction, TNode* pTNode) {
	TNode* temp = searchTNode(nodeIndex);
	if (temp == nullptr) return false;
	//让有本来存在的节点不再被修改
	//if (0 == direction && temp->pLeft != nullptr) return false;
	//if (1 == direction && temp->pRight != nullptr) return false;
	TNode* newTNode = new TNode();	//申请一个新的结点内存
	if (nullptr == newTNode)
		return false;
	newTNode->index = pTNode->index;
	newTNode->data = pTNode->data;
	newTNode->pParent = temp;
	if (0 == direction) temp->pLeft = newTNode;
	if (1 == direction) temp->pRight = newTNode;
	return true;
}

bool Tree::deleteTNode(int nodeIndex, TNode* pTNode) {
	TNode* temp = searchTNode(nodeIndex);
	if (temp == nullptr)
		return false;
	if (pTNode != nullptr)	// 当传入空指针时，不赋值。
		pTNode->data = temp->data;
	temp->deleteTNode();	//通过调用TNode的成员函数。Tree相当于代理类，TNode相当于实现类。
	return true;
}

void Tree::preOrderTraversal() {
	m_pRoot->preOrderTraversal();
}

void Tree::inOrderTraversal() {
	m_pRoot->inOrderTraversal();
}

void Tree::postOrderTraversal() {
	m_pRoot->postOrderTraversal();
}
```



#### 6-2 二叉树编码实战（二） (06:57)

##### Tree--二叉树类模板

```c
#include <iostream>
using namespace std;

template<typename Elem>
class Tree {
public:
	Tree();  //创建树
	~Tree();                            //销毁树
	Elem* searchElem(int elemIndex);//搜索结点
	bool addElem(int elemIndex, int direction, Elem* pElem);//添加结点
	bool deleteElem(int elemIndex, Elem* pElem);//删除结点
	void preOrderTraversal();//前序遍历
	void inOrderTraversal(); //中序遍历
	void postOrderTraversal();//后序遍历
private:
	Elem* m_pRoot;
};

template<typename Elem>
Tree<Elem>::Tree() {
	m_pRoot = new Elem();
}

template<typename Elem>
Tree<Elem>::~Tree() {
	deleteElem(0, nullptr);
	//or m_pRoot->deleteTNode();
}

template<typename Elem>
Elem* Tree<Elem>::searchElem(int elemIndex) {
	return m_pRoot->searchTNode(elemIndex);	//不够通用？
}

template<typename Elem>
bool Tree<Elem>::addElem(int elemIndex, int direction, Elem* pElem) {
	Elem* temp = searchElem(elemIndex);
	if (temp == nullptr) return false;
	//让有本来存在的节点不再被修改
	//if (0 == direction && temp->pLeft != nullptr) return false;
	//if (1 == direction && temp->pRight != nullptr) return false;
	Elem* newElem = new Elem();	//申请一个新的结点内存
	if (nullptr == newElem)
		return false;
	newElem->index = pElem->index;
	newElem->data = pElem->data;
	newElem->pParent = temp;
	if (0 == direction) temp->pLeft = newElem;
	if (1 == direction) temp->pRight = newElem;
	return true;
}

template<typename Elem>
bool Tree<Elem>::deleteElem(int elemIndex, Elem* pElem) {
	Elem* temp = searchElem(elemIndex);
	if (temp == nullptr)
		return false;
	if (pElem != nullptr)	// 当传入空指针时，不赋值。
		pElem->data = temp->data;
	temp->deleteTNode();//通过调用TNode的成员函数。Tree相当于代理类，TNode相当于实现类。
	return true;
}

template<typename Elem>
void Tree<Elem>::preOrderTraversal() {
	m_pRoot->preOrderTraversal();
}

template<typename Elem>
void Tree<Elem>::inOrderTraversal() {
	m_pRoot->inOrderTraversal();
}

template<typename Elem>
void Tree<Elem>::postOrderTraversal() {
	m_pRoot->postOrderTraversal();
}
```

##### 使用

```c
#include <iostream>
#include "Tree.h"
#include "Coordinate.h"
#include "TNode.h"
using namespace std;
/*
				(0)
		5(1)		   8(2)
	2(3)	6(4)	9(5)	7(6)
*/
int main() {
	Tree<TNode>* tree = new Tree<TNode>();
	TNode* n1 = new TNode{ 1, 5 };
	TNode* n2 = new TNode{ 2, 8 };
	TNode* n3 = new TNode{ 3, 2 };
	TNode* n4 = new TNode{ 4, 6 };
	TNode* n5 = new TNode{ 5, 9 };
	TNode* n6 = new TNode{ 6, 7 };
	tree->addElem(0, 0, n1);
	tree->addElem(0, 1, n2);
	tree->addElem(1, 0, n3);
	tree->addElem(1, 1, n4);
	tree->addElem(2, 0, n5);
	tree->addElem(2, 1, n6);
	//tree->deleteElem(6, nullptr);
	//tree->deleteElem(5, nullptr);
	tree->deleteElem(2, nullptr);
	//tree->preOrderTraversal();
	tree->inOrderTraversal();
	//tree->postOrderTraversal();

	delete tree;
}
```



#### 6-3 二叉树编码实战（三） (05:33)

##### TNode--节点类模板

> Todo：TNode的成员函数 T data   如何在构造函数中初始化？
>
> [Done](#TNode--节点类模板2)

```c
#pragma once
#include <iostream>
using namespace std;

template<typename T>
class TNode {
public:
	TNode* searchTNode(int nodeIndex);
	void deleteTNode();
	void preOrderTraversal();
	void inOrderTraversal();
	void postOrderTraversal();
	int index;
	T data;
	TNode* pLeft;
	TNode* pRight;
	TNode* pParent;
};

template<typename T>
TNode<T>* TNode<T>::searchTNode(int nodeIndex) {			//TNode查找的范围是：该节点及子树
	if (this->index == nodeIndex)
		return this;
	if (this->pLeft != nullptr)
		if (this->pLeft->searchTNode(nodeIndex) != nullptr)	//注意：找到了才能return
			return this->pLeft->searchTNode(nodeIndex);		//递归
	if (this->pRight != nullptr)
		if (this->pRight->searchTNode(nodeIndex) != nullptr)//可以不用这句判断，直接返回完事
			return this->pRight->searchTNode(nodeIndex);
	return nullptr;											//注意 找不到要 return NULL
}

template<typename T>
void TNode<T>::deleteTNode() {
	if (this->pLeft != nullptr)
		this->pLeft->deleteTNode();			//递归删除 左子树
	if (this->pRight != nullptr)
		this->pRight->deleteTNode();		//递归删除 右子树
	if (this->pParent != nullptr) {			//这个判断是考虑到根节点没有parent
		if (this->pParent->pLeft == this) {
			this->pParent->pLeft = nullptr;	//把父节点的指针置NULL
		}
		if (this->pParent->pRight == this) {
			this->pParent->pRight = nullptr;
		}
	}
	delete this;							//最后删除自己
}

template<typename T>
void TNode<T>::preOrderTraversal() {
	cout << this->index << ":" << this->data << endl;
	if (this->pLeft != nullptr)
		this->pLeft->preOrderTraversal();
	if (this->pRight != nullptr)
		this->pRight->preOrderTraversal();
}

template<typename T>
void TNode<T>::inOrderTraversal() {
	if (this->pLeft != nullptr)
		this->pLeft->inOrderTraversal();
	cout << this->index << ":" << this->data << endl;
	if (this->pRight != nullptr)
		this->pRight->inOrderTraversal();
}

template<typename T>
void TNode<T>::postOrderTraversal() {
	if (this->pLeft != nullptr)
		this->pLeft->postOrderTraversal();
	if (this->pRight != nullptr)
		this->pRight->postOrderTraversal();
	cout << this->index << ":" << this->data << endl;
}
```

##### 使用

```c
#include <iostream>
#include "Tree.h"
#include "Coordinate.h"
#include "TNode.h"
using namespace std;
int main() {
	Tree<TNode<Coordinate>>* tree = new Tree<TNode<Coordinate>>();
	TNode<Coordinate>* n1 = new TNode<Coordinate>{ 1,{1,1} };
	TNode<Coordinate>* n2 = new TNode<Coordinate>{ 2,{2,2} };
	TNode<Coordinate>* n3 = new TNode<Coordinate>{ 3,{3,3} };
	TNode<Coordinate>* n4 = new TNode<Coordinate>{ 4, 6 };
	TNode<Coordinate>* n5 = new TNode<Coordinate>{ 5, 9 };
	TNode<Coordinate>* n6 = new TNode<Coordinate>{ 6, 7 };
	tree->addElem(0, 0, n1);
	tree->addElem(0, 1, n2);
	tree->addElem(1, 0, n3);
	tree->addElem(1, 1, n4);
	tree->addElem(2, 0, n5);
    
    //tree->preOrderTraversal();
	tree->inOrderTraversal();
	//tree->postOrderTraversal();
	delete tree;
}

#include <iostream>
#include "Tree.h"
#include "Person.h"
#include "TNode.h"
using namespace std;
int main() {
	Tree<TNode<Person>>* tree = new Tree<TNode<Person>>();
	TNode<Person>* n1 = new TNode<Person>{ 1,{"Ygr","9"} };
	TNode<Person>* n2 = new TNode<Person>{ 2,{"ger","1"} };
	TNode<Person>* n3 = new TNode<Person>{ 3,{"You","2"} };
	TNode<Person>* n4 = new TNode<Person>{ 4,{"Fin","3"} };
	TNode<Person>* n5 = new TNode<Person>{ 5,{"Nic","4"} };
	TNode<Person>* n6 = new TNode<Person>{ 6,{"Bjf","5"} };
	tree->addElem(0, 0, n1);
	tree->addElem(0, 1, n2);
	tree->addElem(1, 0, n3);
	tree->addElem(1, 1, n4);
	tree->addElem(2, 0, n5);
	tree->addElem(2, 1, n6);
    
    //tree->preOrderTraversal();
	tree->inOrderTraversal();
	//tree->postOrderTraversal();
	delete tree;
}
```



#### 6-4 二叉树编码实战（四） (10:39)

##### TNode--节点类模板2

> 把TNode的构造函数改成了成员模板
>
> 且该模板支持可变参数

```c
template<typename T>
class TNode {
public:
	template<typename... Args> TNode(int _index = 0, Args... args); //默认构造函数
};

template<typename T>
template<typename... Args>
inline TNode<T>::TNode(int _index, Args... args)	//拓展类型
	:index(_index), data(args...)					//拓展参数
{
	pLeft = nullptr;
	pRight = nullptr;
	pParent = nullptr;
}

template<typename T>
inline TNode<T>* TNode<T>::searchTNode(int nodeIndex)
```

##### 使用

```c
#include <iostream>
#include "Tree.h"
#include "Person.h"
#include "TNode.h"
using namespace std;
int main() {
	Tree<TNode<Person>>* tree = new Tree<TNode<Person>>();
	TNode<Person>* n1 = new TNode<Person>{ 1,"fe","33" };
	TNode<Person>* n2 = new TNode<Person>{ 2,"ger","1" };
	TNode<Person>* n3 = new TNode<Person>{ 3,"You","2" };
	TNode<Person>* n4 = new TNode<Person>{ 4,"Fin","3" };
	TNode<Person>* n5 = new TNode<Person>{ 5,"Nic","4" };
	TNode<Person>* n6 = new TNode<Person>{ 6,"Bjf","5" };
	tree->addElem(0, 0, n1);
	tree->addElem(0, 1, n2);
	tree->addElem(1, 0, n3);
	tree->addElem(1, 1, n4);
	tree->addElem(2, 0, n5);
	tree->addElem(2, 1, n6);

	//tree->preOrderTraversal();
	tree->inOrderTraversal();
	//tree->postOrderTraversal();
	delete tree;
}
```



6-5 二叉树编码实战（五） (10:06)
6-6 二叉树编码实战（六） (18:48)







## [数据结构探险-图篇](https://www.imooc.com/learn/672)

> 简介：本课程主要以图的存储方式，图的遍历方法，图的最小生成树为内容主体，详细讲述了图的存储方式，图的遍历和最小生成树的编程思路及实现原理，并手把手完成图的深度优先遍历算法和广度优先遍历算法。



### 第1章 图的基本概念

> 本章讲解了图的基本概念，如：有向图、无向图、边、弧等。

#### 1-1 课程概述 (10:15)

【有向图】每个节点都叫做“顶点”，顶点之间的有方向的连线叫做**弧**

- 方向箭头的尾端：弧尾

- 方向箭头的头端：弧头

- 某个顶点发射出去的箭头数：出度（数）

- 某个顶点接受到的箭头数：入度（数）

![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200325153308.png)

【无向图】节点间的连线是无方向的（即可以看做双向的），叫做**边**

- 由边连接的两个顶点为邻接点

- 连通图：对于任何顶点都有通往其它顶点的边，即任意两个点之间都是连通的

- 完全图：任意顶点与其它顶点之间都能直接连接，边数与顶点间的数量关系：n(n-1)/2

![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200325153411.png)

生成树：边数与顶点间的数量关系：n-1



图的应用：

![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200325153115.png)



### 第2章 图的存储结构、遍历方式及最小生成树算法原理

> 本章详细讲述了图的几种常用存储结构、遍历方式及普里姆算法和克鲁斯卡尔算法的设计思路。



#### 2-1 图的基本概念及存储方式（一) (15:28)

> Todo：https://www.cnblogs.com/wkfvawl/p/9985083.html

![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200325153736.png)



##### 邻接矩阵 adjacency matrix

> 数组存储

- 顶点 和 弧的数据结构

  ![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200325154408.png)

- 数据结构伪代码

  ![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200325155144.png)

- 有向图的邻接矩阵 -- 二维数组

  ![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200325154552.png)

- 无向图的邻接矩阵（对称）-- 可以只存储一半

  ![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200325154719.png)

  

##### 邻接表 adjacency list

> 链式存储 -- 有向图

> 记录出弧数据的链表
>
> 逆邻接表：记录的是 入弧链表头指针 和 弧尾顶点索引

- 顶点 和 弧的数据结构

  - 顶点：顶点索引+出弧链表头指针+顶点数据
  - 出弧链表头指针：通过它找到这个顶点的所有出弧
  - 弧：弧头顶点索引+下一条弧指针+弧数据

  ![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200325155643.png)

- 顶点 和 弧的数据结构2

  ![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200325155832.png)

- 数据结构伪代码

  - struct Node{顶点索引；该顶点弧链表的头结点；顶点数据；}
  - struct Arc{指向的顶点索引；指向下一条弧的指针；弧信息；}
  - struct Map{顶点数组；}

  ![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200325160121.png)

##### 十字链表 orthogonal list

> 链式存储 -- 有向图

- 顶点 和 弧的数据结构

  - 顶点：顶点索引+顶点数据+以该顶点为弧尾的弧节点指针+以该节点为弧头的弧节点指针
  - 弧：弧尾顶点索引+弧头顶点索引+弧尾相同的下一条弧的指针+弧头相同的下一条弧的指针+弧的数据

  ![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200325162543.png)

- 数据结构伪代码

  - struct Node{顶点索引；顶点数据；第一条入弧节点指针；第一条出弧节点指针；}
  - struct Arc{弧尾顶点索引；弧头顶点索引；指向下一条弧头相同的弧的指针；指向下一条弧尾相同的弧的指针；弧的数据；}
  - struct Map{顶点数组；}

  ![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200325163009.png)

##### 邻接多重表 adjacency multilist

> 链式存储 -- 无向图

- 顶点 和 边的数据结构

  - 顶点：顶点索引+连接该顶点的边+顶点数据
  - 边：A顶点索引+B顶点索引+与A顶点相连接的下一条边的指针+与B顶点相连接的下一条边的指针+边的数据

  ![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200325191504.png)

- 数据结构伪代码

  - struct Node{顶点索引；顶点数据；第一条边节点的指针；}
  - struct Edge{顶点A索引；顶点B索引；连接A的下一条边的指针；连接B的下一条边的指针；边信息；}
  - struct Map{顶点数组；}

  ![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200325202751.png)



2-2 图的基本概念及存储方式（二） (06:37)



#### 2-3 图的遍历及最小生成树 (14:04)

##### 图的遍历

1.广度搜索：按层次搜索

![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200325225505.png)

2.深度搜索：相当于树的前序遍历

![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200325225532.png)

##### 最小生成树

###### prim-普里姆算法：

- 已选点集，已选边集，待选边集

- 假设从顶点A开始， 先选距离A最近的顶点（比如F），然后把F点放入已选顶点集合当中，A-F边放入已选边的集合中。之后将A和F看作一个整体，再去找离这个整体最近的点和边。

- 前提是选的一条边如果形成成闭环，则舍弃掉这条边。

  ![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200325225158.png)



###### kruskal-克鲁斯卡尔算法：

- 待选边集合，已选边集合，已涉及点集合

- 先把所有的边找到，从待选边中选一条权最小的边，将该边加入已选边集合，将这条边连接的两个点加入到已涉及点集合。每一次都去找所有边中最短的那一条。不断的把顶点连接起来，直到所有的顶点都放入顶点集合中 并且通过边形成同一个集合为止。

- 前提是选的一条边如果形成成闭环，则舍弃掉这条边。

  ![](https://gitee.com/kiss-younger/pictures/raw/master/picgo/20200325223800.png)



### 第3章 图的基本操作与遍历

> 本章详细讲述了图的基本操作及深度优先遍历和广度优先遍历，并通过编码对理论知识逐一落实到编码中。

#### 3-1 图的编码实战-图的编码说明

##### GNode--节点类

```c
// GNode.h
#pragma once
class GNode {
public:
	GNode(char _data = 0);
	char data;
	bool isVisited;
};

// GNode.cpp
#include "GNode.h"
GNode::GNode(char _data) {
	data = _data;
	isVisited = false;
}
```



##### AdMatrixGraph--邻接矩阵图类

```c
// AdMatrixGraph.h
#pragma once
#include "GNode.h"
#include <vector>
class AdMatrixGraph {
public:
	AdMatrixGraph(int _capacity);
	~AdMatrixGraph();
	bool addNode(GNode* pGNode);
	void resetNode();						//重置顶点为未访问
	bool setValueToMatrixForDirectedGraph(int row, int col, int val = 1);		
		//为有向图设置邻接矩阵的权值
	bool setValueToMatrixForUndirectedGraph(int row, int col, int val = 1);		
		//为无向图设置邻接矩阵的权值
	void printMatrix();						//打印邻接矩阵
	void depthFirstTraverse(int nodeIndex);	//深度优先遍历
	void breadthFirstTraverse(int nodeIndex);//广度优先遍历
private:
	bool getValueFromMatrix(int row, int col, int& val);			//从矩阵中获取权值
	void breadthFirtTraverseImplementation(std::vector<int>& preVec);//广度优先遍历实现函数
private:
	int capacity;	//图的容量(可容纳顶点数)
	int nodeCount;	//当前顶点数
	GNode* pNode;	//存放顶点
	int* pMatrix;	//存放邻接矩阵
};
```

```c
// AdMatrixGraph.cpp
#include "AdMatrixGraph.h"
#include <iostream>
using namespace std;

AdMatrixGraph::AdMatrixGraph(int _capacity) {
	capacity = _capacity;
	nodeCount = 0;
	pNode = new GNode[capacity];									//为顶点分配内存
	pMatrix = new int[capacity * capacity];							//为邻接矩阵分配内存
	for (int i = 0; i < capacity * capacity; i++) {					//初始化邻接矩阵
		pMatrix[i] = 0;
	}
	// std::memset(pMatrix, 0, capacity * capacity * sizeof(int));	//需 #include <cstring>
}

AdMatrixGraph::~AdMatrixGraph() {
	delete[]pNode;
	delete[]pMatrix;
}

bool AdMatrixGraph::addNode(GNode* pGNode) {
	if (pGNode == nullptr)
		return false;
	pNode[nodeCount].data = pGNode->data;
	nodeCount++;
	return true;
}

void AdMatrixGraph::resetNode() {
	for (int i = 0; i < nodeCount; i++) {
		pNode[i].isVisited = false;
	}
}

bool AdMatrixGraph::setValueToMatrixForDirectedGraph(int row, int col, int val) {
	if (row < 0 || row >= capacity || col < 0 || col >= capacity)
		return false;
	pMatrix[row * capacity + col] = val;
	return true;
}

bool AdMatrixGraph::setValueToMatrixForUndirectedGraph(int row, int col, int val) {
	if (row < 0 || row >= capacity || col < 0 || col >= capacity)
		return false;
	pMatrix[row * capacity + col] = val;
	pMatrix[col * capacity + row] = val;
	return true;
}

void AdMatrixGraph::printMatrix() {
	for (int j = 0; j < capacity; j++) {
		for (int k = 0; k < capacity; k++)
			cout << pMatrix[j * capacity + k] << " ";
		cout << endl;
	}
}

void AdMatrixGraph::depthFirstTraverse(int nodeIndex) {
	cout << pNode[nodeIndex].data << ' ';
	pNode[nodeIndex].isVisited = true;						//打印，访问当前节点

	int value;
	for (int i = 0; i < capacity; i++) {
		getValueFromMatrix(nodeIndex, i, value);
		if (1 == value && false == pNode[i].isVisited) {	//如果是i位置是未访问的邻接点
			depthFirstTraverse(i);
		}
	}
}

void AdMatrixGraph::breadthFirstTraverse(int nodeIndex) {
	cout << pNode[nodeIndex].data << ' ';
	pNode[nodeIndex].isVisited = true;						//打印，访问当前节点

	std::vector<int> curVec;
	curVec.push_back(nodeIndex);
	breadthFirtTraverseImplementation(curVec);
}

bool AdMatrixGraph::getValueFromMatrix(int row, int col, int& val) {
	if (row < 0 || row >= capacity || col < 0 || col >= capacity)
		return false;
	val = pMatrix[row * capacity + col];
	return true;
}

void AdMatrixGraph::breadthFirtTraverseImplementation(std::vector<int>& preVec) {
	int value = 0;
	std::vector<int> curVec;			//通过上一层节点preVec，把访问到的邻接点放入当前层curVec
	for (int j = 0; j < (int)preVec.size(); j++)				//类型强制转换
		for (int k = 0; k < capacity; k++) {
			getValueFromMatrix(preVec[j], k, value);
			if (1 == value && false == pNode[k].isVisited) {	//如果是k位置是未访问的邻接点
				cout << pNode[k].data << ' ';
				pNode[k].isVisited = true;
				curVec.push_back(k);
			}
		}
	if (0 == curVec.size())
		return;
	breadthFirtTraverseImplementation(curVec);
}
```

##### 使用

```c
#include <iostream>
#include "GNode.h"
#include "AdMatrixGraph.h"
using namespace std;
/*
		 A
	   /   \
	  B     D
	 / \   / \
	C   F G - H
	 \ /
	  E
*/
int main() {
	AdMatrixGraph* pGraph = new AdMatrixGraph(8);
	GNode* pNodeA = new GNode('A');
	GNode* pNodeB = new GNode('B');
	GNode* pNodeC = new GNode('C');
	GNode* pNodeD = new GNode('D');
	GNode* pNodeE = new GNode('E');
	GNode* pNodeF = new GNode('F');
	GNode* pNodeG = new GNode('G');
	GNode* pNodeH = new GNode('H');

	pGraph->addNode(pNodeA);
	pGraph->addNode(pNodeB);
	pGraph->addNode(pNodeC);
	pGraph->addNode(pNodeD);
	pGraph->addNode(pNodeE);
	pGraph->addNode(pNodeF);
	pGraph->addNode(pNodeG);
	pGraph->addNode(pNodeH);
	/*
		  A B C D E F G H
		A   1   1
		B     1     1
		C         1
		D             1 1
		E           1
		F
		G               1
		H
	*/
	pGraph->setValueToMatrixForUndirectedGraph(0, 1);
	pGraph->setValueToMatrixForUndirectedGraph(0, 3);
	pGraph->setValueToMatrixForUndirectedGraph(1, 2);
	pGraph->setValueToMatrixForUndirectedGraph(1, 5);
	pGraph->setValueToMatrixForUndirectedGraph(2, 4);
	pGraph->setValueToMatrixForUndirectedGraph(3, 6);
	pGraph->setValueToMatrixForUndirectedGraph(3, 7);
	pGraph->setValueToMatrixForUndirectedGraph(4, 5);
	pGraph->setValueToMatrixForUndirectedGraph(6, 7);

	pGraph->printMatrix();
	cout << endl;
	pGraph->depthFirstTraverse(0);
	cout << endl;
	pGraph->resetNode();
	pGraph->breadthFirstTraverse(0);
}
```

3-2 图的编码实战-图的基本操作（一） (10:10)
3-4 图的编码实战-图的基本操作（二） (06:53)
3-5 图的编码实战-图的深度优先遍历 (06:36)
3-6 图的编码实战-图的广度优先遍历 (13:16)
3-7 图的编码实战-图的编码阶段检测 (08:52)



### 第4章 图的最小生成树算法

> 本章讲述了最为经典的普里姆算法和克鲁斯卡尔算法并详细讲述编码思路和技巧。

- 依赖于节点的isVisited：深度、广度优先遍历，prim最小生成树

- 依赖于边的isSelected：kruskal最小生成树，prim最小生成树



#### 4-1 图的编码实战-最小生成树之普利姆算法（一） 

##### 避免成环的算法设计：

- 每选一个点都要置为已访问
- 先选一个点，然后通过每选一条最小边来选一个未访问的点，从而遍历完n个点和n-1条边
- 因为是未访问的点，所以选的边们不会成环

##### Edge--边类

```c
// Edge.h
#pragma once
class Edge {
public:
	Edge(int _XNodeIndex = 0, int _YNodeIndex = 0, int _weight = 0);
	int XNodeIndex;
	int YNodeIndex;
	int weight;
	bool isSelected;
};

//Edge.cpp
#include "Edge.h"
Edge::Edge(int _XNodeIndex, int _YNodeIndex, int _weight) {
	XNodeIndex = _XNodeIndex;
	YNodeIndex = _YNodeIndex;
	weight = _weight;
	isSelected = false;
}
```

4-2 图的编码实战-最小生成树之普利姆算法（二） (19:04)
4-3 图的编码实战-最小生成树之普利姆算法（三） (09:01)
4-4 图的编码实战-最小生成树之普利姆算法（四） (08:24)



#### 4-5 图的编码实战-最小生成树之克鲁斯卡尔算法（一） (07:42)

##### 避免成环的算法设计： 

- 把通过已选边确定的已选的点分成不同的集合
- 看看当前最小边的两端点属于哪一种情况：
  - 两个点都不在任何集合
  - 一个点在一个集合，一个点不在任何集合
  - 两个点都在同一个集合
  - 两个点都在不同集合
- 把第三种情况的点舍弃，就能避免成环

**程序写完后要检查申请的内存资源是否都被释放了**

##### AdMatrixGraph--邻接矩阵图类

```cpp
//AdMatrixGraph.h
#pragma once
#include "GNode.h"
#include "Edge.h"
#include <vector>
class AdMatrixGraph {
public:
	AdMatrixGraph(int _capacity);
	~AdMatrixGraph();
	bool addNode(GNode* pGNode);
	void resetNode();						//重置顶点为未访问
	bool setValueToMatrixForDirectedGraph(int row, int col, int val = 1);		
    	//为有向图设置邻接矩阵的权值
	bool setValueToMatrixForUndirectedGraph(int row, int col, int val = 1);	
    	//为无向图设置邻接矩阵的权值
	void printMatrix();						//打印邻接矩阵
	void depthFirstTraverse(int nodeIndex);	//深度优先遍历
	void breadthFirstTraverse(int nodeIndex);//广度优先遍历

	void primTree(int nodeIndex);		//普里姆最小生成树
	void kruscalTree();					//克鲁斯卡尔最小生成树
private:
	bool getValueFromMatrix(int row, int col, int& val);			//从矩阵中获取权值
	void breadthFirtTraverseImplementation(std::vector<int>& preVec);//广度优先遍历实现函数
	int  getMinWeightEdge(std::vector<Edge>& edgeVec);
	bool isNodeInSet(std::vector<int>& nodeSet, int nodeIndex);
	void mergeNodeSet(std::vector<int>& nodeSetA, std::vector<int>& nodeSetB);
private:
	int capacity;	//图的容量(可容纳顶点数)
	int nodeCount;	//当前顶点数
	GNode* pNode;	//存放顶点
	int* pMatrix;	//存放邻接矩阵

	Edge* pEdge;	//存放最小生成树的已选边
};
```

```c
#include "AdMatrixGraph.h"
#include <iostream>
using namespace std;

AdMatrixGraph::AdMatrixGraph(int _capacity) {
	capacity = _capacity;
	nodeCount = 0;
	pNode = new GNode[capacity];									//为顶点分配内存
	pMatrix = new int[capacity * capacity];							//为邻接矩阵分配内存
	for (int i = 0; i < capacity * capacity; i++) {					//初始化邻接矩阵
		pMatrix[i] = 0;
	}
	// std::memset(pMatrix, 0, capacity * capacity * sizeof(int));	
    	//需 #include <cstring>
	pEdge = new Edge[capacity - 1];							//最大边数 = 最大点数 - 1
}

AdMatrixGraph::~AdMatrixGraph() {
	delete[]pNode;
	delete[]pMatrix;
	delete[]pEdge;
}

bool AdMatrixGraph::addNode(GNode* pGNode) {
	if (pGNode == nullptr)
		return false;
	pNode[nodeCount].data = pGNode->data;
	nodeCount++;
	return true;
}

void AdMatrixGraph::resetNode() {
	for (int i = 0; i < nodeCount; i++) {
		pNode[i].isVisited = false;
	}
}

bool AdMatrixGraph::setValueToMatrixForDirectedGraph(int row, int col, int val) {
	if (row < 0 || row >= capacity || col < 0 || col >= capacity)
		return false;
	pMatrix[row * capacity + col] = val;
	return true;
}

bool AdMatrixGraph::setValueToMatrixForUndirectedGraph(int row, int col, int val) {
	if (row < 0 || row >= capacity || col < 0 || col >= capacity)
		return false;
	pMatrix[row * capacity + col] = val;
	pMatrix[col * capacity + row] = val;
	return true;
}

void AdMatrixGraph::printMatrix() {
	for (int j = 0; j < capacity; j++) {
		for (int k = 0; k < capacity; k++)
			cout << pMatrix[j * capacity + k] << " ";
		cout << endl;
	}
}

void AdMatrixGraph::depthFirstTraverse(int nodeIndex) {
	cout << pNode[nodeIndex].data << ' ';
	pNode[nodeIndex].isVisited = true;						//打印，访问当前节点

	int value;
	for (int i = 0; i < nodeCount; i++) {
		getValueFromMatrix(nodeIndex, i, value);
		if (1 == value && false == pNode[i].isVisited) {	//如果是i位置是未访问的邻接点
			depthFirstTraverse(i);
		}
	}
}

void AdMatrixGraph::breadthFirstTraverse(int nodeIndex) {
	cout << pNode[nodeIndex].data << ' ';
	pNode[nodeIndex].isVisited = true;						//打印，访问当前节点

	std::vector<int> curVec;
	curVec.push_back(nodeIndex);
	breadthFirtTraverseImplementation(curVec);
}

void AdMatrixGraph::primTree(int nodeIndex) {
	int tempWeight = 0;
	int edgeCount = 0;
	std::vector<int> nodeVec;	//存放最小生成树的已遍历点索引
	std::vector<Edge> edgeVec;	//存放最小生成树的待选边

	cout << pNode[nodeIndex].data << endl;
	pNode[nodeIndex].isVisited = true;	//每次访问完，都要立flag
	nodeVec.push_back(nodeIndex);

	while (edgeCount < nodeCount - 1) {	//or nodeVec.size()<nodeCount	//算法结束条件
		int tempIndex = nodeVec.back();
		for (int i = 0; i < nodeCount; i++) {
			getValueFromMatrix(tempIndex, i, tempWeight);
			if (0 != tempWeight && false == pNode[i].isVisited) {
				edgeVec.push_back(Edge{ tempIndex,i,tempWeight });
			}
		}

		int edgeIndex = getMinWeightEdge(edgeVec);

		cout << edgeVec[edgeIndex].XNodeIndex << "--" << edgeVec[edgeIndex].YNodeIndex << ' ';
		cout << edgeVec[edgeIndex].weight << endl;
		edgeVec[edgeIndex].isSelected = true;

		pEdge[edgeCount] = edgeVec[edgeIndex];
		edgeCount++;

		int nextNodeIndex = edgeVec[edgeIndex].YNodeIndex;	
        	//Edge{tempIndex,i,}中tempIndex已被访问过,下一个点是i，即YNode。

		nodeVec.push_back(nextNodeIndex);
		cout << pNode[nextNodeIndex].data << endl;
		pNode[nextNodeIndex].isVisited = true;
	}
}

void AdMatrixGraph::kruscalTree() {
	int tempWeight = 0;
	int edgeCount = 0;
	//存放节点集合的向量，即nodeSets中每个元素都是一个节点集合
	std::vector<std::vector<int>> nodeSets;
	//第一步：取出所有边
	std::vector<Edge> edgeVec;
	for (int i = 0; i < nodeCount; i++) {
		for (int k = i + 1; k < nodeCount; k++) {
			getValueFromMatrix(i, k, tempWeight);
			if (0 != tempWeight) {
				edgeVec.push_back(Edge{ i,k,tempWeight });
			}
		}
	}
	//第二步：依次取最小的边
	while (edgeCount < nodeCount - 1) {	//算法结束条件
		//1 取当前最小边
		int edgeIndex = getMinWeightEdge(edgeVec);
		edgeVec[edgeIndex].isSelected = true;
		//2 最小边的两个端点
		int ANodeIndex = edgeVec[edgeIndex].XNodeIndex;
		int BNodeIndex = edgeVec[edgeIndex].YNodeIndex;
		//3 找到两个点所在的集合
		bool AInSet = false;
		bool BInSet = false;
		int ASetIndex = -1;
		int BSetIndex = -1;
		for (int i = 0; (int)i < nodeSets.size(); i++) {
			bool AInSet = isNodeInSet(nodeSets[i], ANodeIndex);
			if (true == AInSet) {
				ASetIndex = i;
				break;
			}
		}
		for (int i = 0; (int)i < nodeSets.size(); i++) {
			bool BInSet = isNodeInSet(nodeSets[i], BNodeIndex);
			if (true == BInSet) {
				BSetIndex = i;
				break;
			}
		}
		//4 根据点所在集合的不同作不同处理
		if (-1 == ASetIndex && -1 == BSetIndex) {
			std::vector<int> newNodeSet;
			newNodeSet.push_back(ANodeIndex);
			newNodeSet.push_back(BNodeIndex);
			nodeSets.push_back(newNodeSet);
		}
		else if (-1 == ASetIndex && -1 != BSetIndex) {
			nodeSets[BSetIndex].push_back(ANodeIndex);
		}
		else if (-1 != ASetIndex && -1 == BSetIndex) {
			nodeSets[ASetIndex].push_back(BNodeIndex);
		}
		else if (-1 != ASetIndex && -1 != BSetIndex && ASetIndex == BSetIndex) {
			continue;
		}
		else {
			mergeNodeSet(nodeSets[ASetIndex], nodeSets[BSetIndex]);
			//nodeSets.erase(nodeSets.begin() + BSetIndex);
		}
		pEdge[edgeCount] = edgeVec[edgeIndex];
		edgeCount++;

		cout << edgeVec[edgeIndex].XNodeIndex << "--" << edgeVec[edgeIndex].YNodeIndex << ' ';
		cout << edgeVec[edgeIndex].weight << endl;
	}
}

bool AdMatrixGraph::getValueFromMatrix(int row, int col, int& val) {
	if (row < 0 || row >= capacity || col < 0 || col >= capacity)
		return false;
	val = pMatrix[row * capacity + col];
	return true;
}

void AdMatrixGraph::breadthFirtTraverseImplementation(std::vector<int>& preVec) {
	int value = 0;
	std::vector<int> curVec;	//通过上一层节点preVec，把访问到的邻接点放入当前层curVec
	for (int j = 0; j < (int)preVec.size(); j++)				//类型强制转换
		for (int k = 0; k < nodeCount; k++) {
			getValueFromMatrix(preVec[j], k, value);
			if (1 == value && false == pNode[k].isVisited) {	//如果是k位置是未访问的邻接点
				cout << pNode[k].data << ' ';
				pNode[k].isVisited = true;
				curVec.push_back(k);
			}
		}
	if (0 == curVec.size())
		return;
	breadthFirtTraverseImplementation(curVec);
}

int AdMatrixGraph::getMinWeightEdge(std::vector<Edge>& edgeVec) {
	int edgeIndex = -1;
	int minEdgeWeight = INT_MAX;
	int i = 0;
	//为了得到第一个未被选择的edge.weight，以和其他edge.weight比较
	//int minEdgeWeight = 0;
	//for (; i < (int)edgeVec.size(); i++) {
	//	if (false == edgeVec[i].isSelected) {
	//		minEdgeWeight = edgeVec[i].weight;
	//		edgeIndex = i;
	//		break;	//记得break
	//	}
	//}
	for (; i < (int)edgeVec.size(); i++) {
		if (false == edgeVec[i].isSelected) {
			if (minEdgeWeight > edgeVec[i].weight) {
				minEdgeWeight = edgeVec[i].weight;
				edgeIndex = i;
			}
		}
	}
	return edgeIndex;
}

bool AdMatrixGraph::isNodeInSet(std::vector<int>& nodeSet, int nodeIndex) {
	for (int i = 0; i < (int)nodeSet.size(); i++) {
		if (nodeSet[i] == nodeIndex)
			return true;
	}
	return false;
}

void AdMatrixGraph::mergeNodeSet(std::vector<int>& nodeSetA, std::vector<int>& nodeSetB) {
	for (int i = 0; i < (int)nodeSetB.size(); i++) {
		nodeSetA.push_back(nodeSetB[i]);
	}
	nodeSetB.clear();
}
```



##### 使用

```c
#include <iostream>
#include "GNode.h"
#include "AdMatrixGraph.h"
using namespace std;
/*
		 A
	  /  |  \
	B -- F -- E
	 \  / \  /
	  C -- D
	A B C D E F
	0 1 2 3 4 5
  AB=6 AF=1 AE=5
  BF=2 FE=9
  BC=3 FC=8 FD=4 ED=2
  CD=7
*/
int main() {
	AdMatrixGraph* pGraph = new AdMatrixGraph(6);
	GNode* pNodeA = new GNode('A');
	GNode* pNodeB = new GNode('B');
	GNode* pNodeC = new GNode('C');
	GNode* pNodeD = new GNode('D');
	GNode* pNodeE = new GNode('E');
	GNode* pNodeF = new GNode('F');

	pGraph->addNode(pNodeA);
	pGraph->addNode(pNodeB);
	pGraph->addNode(pNodeC);
	pGraph->addNode(pNodeD);
	pGraph->addNode(pNodeE);
	pGraph->addNode(pNodeF);

	pGraph->setValueToMatrixForUndirectedGraph(0, 1, 6);
	pGraph->setValueToMatrixForUndirectedGraph(0, 5, 1);
	pGraph->setValueToMatrixForUndirectedGraph(0, 4, 5);
	pGraph->setValueToMatrixForUndirectedGraph(1, 5, 2);
	pGraph->setValueToMatrixForUndirectedGraph(5, 4, 9);
	pGraph->setValueToMatrixForUndirectedGraph(1, 2, 3);
	pGraph->setValueToMatrixForUndirectedGraph(5, 2, 8);
	pGraph->setValueToMatrixForUndirectedGraph(5, 3, 4);
	pGraph->setValueToMatrixForUndirectedGraph(4, 3, 2);
	pGraph->setValueToMatrixForUndirectedGraph(2, 3, 7);

	//pGraph->primTree(0);
	pGraph->kruscalTree();
}
```

4-6 图的编码实战-最小生成树之克鲁斯卡尔算法（二） (20:10)
4-7 图的编码实战-最小生成树之克鲁斯卡尔算法（三） (05:10)
4-8 图的编码实战-最小生成树之克鲁斯卡尔算法（四） (05:05)